// Copyright 2011-18 Paul Kulchenko, ZeroBrane LLC
// authors: Luxinia Dev (Eike Decker & Christoph Kubisch)
//-------------------------------------------------------

var ide = ide;

ide.filetree = {
  projdir = "",
  projdirlist = {},
  projdirpartmap = {},
  projtreeCtrl = null,
  imglist = ide->CreateImageList("PROJECT",
    "FOLDER", "FOLDER-MAPPED", "FILE-NORMAL", "FILE-NORMAL-START",
    // "file known" needs to be the last one as dynamic types can be added after it
    "FILE-KNOWN"),
  settings = {extensionignore = {}, startfile = {}, mapped = {}},
  extmap = {},
};
var filetree = ide.filetree;
var iscaseinsensitive = wx.wxFileName("A")->SameAs(wx.wxFileName("a"));
var pathsep = GetPathSeparator();
var q = EscapeMagic;
var image = { // the order of ids has to match the order in the ImageList
  DIRECTORY = 0, DIRECTORYMAPPED = 1, FILEOTHER = 2, FILEOTHERSTART = 3,
  FILEKNOWN = 4,
};

var clearbmp = ide->GetBitmap("FILE-NORMAL-CLR", "PROJECT", wx.wxSize(16,16));
var function str2rgb(str) {
  var a = ('a')->byte();
  // `red`/`blue` are more prominent colors; use them for the first two letters; suppress `green`
  var r = (((str->sub(1,1)->lower()->byte() || a)-a) % 27)/27;
  var b = (((str->sub(2,2)->lower()->byte() || a)-a) % 27)/27;
  var g = (((str->sub(3,3)->lower()->byte() || a)-a) % 27)/27/3;
  var ratio = 256/(r + g + b + 1e-6);
  return {math.floor(r*ratio), math.floor(g*ratio), math.floor(b*ratio)};
}
var function createImg(ext) {
  var iconmap = ide.config.filetree.iconmap;
  var color = type(iconmap)=="table" && type(iconmap[ext])=="table" && iconmap[ext].fg;
  var bitmap = wx.wxBitmap(16, 16);
  var font = wx.wxFont(ide.font.editor);
  font->SetPointSize(ide.osname == "Macintosh" && 6 || 5);
  var mdc = wx.wxMemoryDC();
  mdc->SelectObject(bitmap);
  mdc->SetFont(font);
  mdc->DrawBitmap(clearbmp, 0, 0, true);
  mdc->SetTextForeground(wx.wxColour(unpack(type(color)=="table" && color || str2rgb(ext))));
  mdc->DrawText(ext->sub(1,3), 2, 5); // take first three letters only
  mdc->SelectObject(wx.wxNullBitmap);
  return bitmap;
}

var function getIcon(name, isdir) {
  var project = ide->GetProject();
  var startfile = GetFullPathIfExists(project, filetree.settings.startfile[project]);
  var ext = GetFileExt(name);
  var extmap = ide.filetree.extmap;
  var known = extmap[ext] || ide->FindSpec(ext);
  if( known && ! extmap[ext] ) {
    var iconmap = ide.config.filetree.iconmap;
    extmap[ext] = iconmap && ide.filetree.imglist->Add(createImg(ext)) || image.FILEKNOWN;
  }
  var icon = isdir && image.DIRECTORY || known && extmap[ext] || image.FILEOTHER;
  if( startfile && startfile == name ) { icon = image.FILEOTHERSTART; }
  return icon;
}

var function treeAddDir(tree,parent_id,rootdir) {
  var items = {};
  var item, cookie = tree->GetFirstChild(parent_id);
  while( item->IsOk() ) {
    items[tree->GetItemText(item) .. tree->GetItemImage(item)] = item;
    item, cookie = tree->GetNextChild(parent_id, cookie);
  }

  var cache = {};
  var curr;
  var files = ide->GetFileList(rootdir);
  var dirmapped = {};
  var projpath = ide->GetProject();
  if( tree->IsRoot(parent_id) ) {
    var mapped = filetree.settings.mapped[projpath] || {};
    table.sort(mapped);
    // insert into files at the sorted order
    for( i, v in ipairs(mapped) ) {
      table.insert(files, i, v);
      dirmapped[v] = true;
    }
  }

  for( _, file in ipairs(files) ) {
    var name, dir = file->match("([^"..pathsep.."]+)("..pathsep.."?)$");
    var isdir = #dir>0;
    if( isdir || ! filetree.settings.extensionignore[GetFileExt(name)] ) {
      var icon = getIcon(file, isdir);

      // keep full name for the mapped directories
      if( dirmapped[file] ) {
        name = file->gsub(q(projpath), "")->gsub(pathsep.."$","");
        icon = image.DIRECTORYMAPPED;
      }

      var item = items[name .. icon];
      if( item ) { // existing item
        // keep deleting items until we find item
        while( true ) {
          var nextitem = (curr
            && tree->GetNextSibling(curr)
            || tree->GetFirstChild(parent_id));
          if( ! nextitem->IsOk() || name == tree->GetItemText(nextitem) ) {
            curr = nextitem;
            break;
          }
          PackageEventHandle("onFiletreeFileRemove", tree, nextitem, tree->GetItemFullName(nextitem));
          tree->Delete(nextitem);
        }
      } else { // new item
        curr = (curr
          && tree->InsertItem(parent_id, curr, name, icon)
          || tree->PrependItem(parent_id, name, icon));
        if( isdir ) { tree->SetItemHasChildren(curr, FileDirHasContent(file)); }
        PackageEventHandle("onFiletreeFileAdd", tree, curr, file);
      }
      if( curr->IsOk() ) { cache[iscaseinsensitive && name->lower() || name] = curr; }
    }
  }

  // delete any leftovers (something that exists in the tree, but not on disk)
  while( true ) {
    var nextitem = (curr
      && tree->GetNextSibling(curr)
      || tree->GetFirstChild(parent_id));
    if( ! nextitem->IsOk() ) { break; }
    PackageEventHandle("onFiletreeFileRemove", tree, nextitem, tree->GetItemFullName(nextitem));
    tree->Delete(nextitem);
  }

  // cache the mapping from names to tree items
  if( ide.wxver >= "2.9.5" ) {
    var data = wx.wxLuaTreeItemData();
    data->SetData(cache);
    tree->SetItemData(parent_id, data);
  }

  tree->SetItemHasChildren(parent_id,
    tree->GetChildrenCount(parent_id, false) > 0);

  PackageEventHandle("onFiletreeFileRefresh", tree, parent_id, tree->GetItemFullName(parent_id));
}

var function treeSetRoot(tree,rootdir) {
  if( ! ide->IsValidCtrl(tree) ) { return; }
  tree->DeleteAllItems();
  if( ! wx.wxDirExists(rootdir) ) { return; }

  var root_id = tree->AddRoot(rootdir, image.DIRECTORY);
  tree->SetItemHasChildren(root_id, true); // make sure that the item can expand
  tree->Expand(root_id); // this will also populate the tree
}

var function findItem(tree, match) {
  var node = tree->GetRootItem();
  var label = tree->GetItemText(node);

  var s, e;
  if( iscaseinsensitive ) {
    s, e = string.find(match->lower(), label->lower(), 1, true);
  } else {
    s, e = string.find(match, label, 1, true);
  }
  if( ! s || s != 1 ) { return; }

  for( token in string.gmatch(string.sub(match,e+1), "[^%"..pathsep.."]+") ) {
    var data = tree->GetItemData(node);
    var cache = data && data->GetData();
    if( cache && cache[iscaseinsensitive && token->lower() || token] ) {
      node = cache[iscaseinsensitive && token->lower() || token];
    } else {
      // token is missing; may need to re-scan the folder; maybe new file
      var dir = tree->GetItemFullName(node);
      treeAddDir(tree,node,dir);

      var item, cookie = tree->GetFirstChild(node);
      while( true ) {
        if( ! item->IsOk() ) { return; } // not found
        if( tree->GetItemText(item) == token ) {
          node = item;
          break;
        }
        item, cookie = tree->GetNextChild(node, cookie);
      }
    }
  }

  // this loop exits only when a match is found
  return node;
}

var function treeSetConnectorsAndIcons(tree) {
  tree->AssignImageList(filetree.imglist);

  var function isIt(item, imgtype) { return tree->GetItemImage(item) == imgtype; }

  function tree::IsDirectory(item_id) { return isIt(item_id, image.DIRECTORY); }
  function tree::IsDirMapped(item_id) { return isIt(item_id, image.DIRECTORYMAPPED); }
  // "file known" is a special case as it includes file types registered dynamically
  function tree::IsFileKnown(item_id) { return tree->GetItemImage(item_id) >= image.FILEKNOWN; }
  function tree::IsFileOther(item_id) { return isIt(item_id, image.FILEOTHER); }
  function tree::IsFileStart(item_id) { return isIt(item_id, image.FILEOTHERSTART); }
  function tree::IsRoot(item_id) { return ! tree->GetItemParent(item_id)->IsOk(); }

  var function saveSettings() {
    ide->AddPackage('core.filetree', {})->SetSettings(filetree.settings);
  }

  function tree::FindItem(match) {
    return findItem(this, (wx.wxIsAbsolutePath(match) || match == '') && match
      || MergeFullPath(ide->GetProject(), match));
  }

  function tree::GetItemFullName(item_id) {
    var tree = this;
    var str = tree->GetItemText(item_id);
    var cur = str;

    while( (#cur > 0) ) {
      item_id = tree->GetItemParent(item_id);
      if( ! item_id->IsOk() ) { break; }
      cur = tree->GetItemText(item_id);
      if( cur && #cur > 0 ) { str = MergeFullPath(cur, str); }
    }
    // as root may already include path separator, normalize the path
    var fullPath = wx.wxFileName(str);
    fullPath->Normalize();
    return fullPath->GetFullPath();
  }

  function tree::RefreshChildren(node) {
    node = node || tree->GetRootItem();
    treeAddDir(tree,node,tree->GetItemFullName(node));
    var item, cookie = tree->GetFirstChild(node);
    while( true ) {
      if( ! item->IsOk() ) { return; }
      if( tree->IsExpanded(item) ) { tree->RefreshChildren(item); }
      item, cookie = tree->GetNextChild(node, cookie);
    }
  }

  var function refreshAncestors(node) {
    // when this method is called from END_EDIT, it causes infinite loop
    // on OSX (wxwidgets 2.9.5) as Delete in treeAddDir calls END_EDIT again.
    // disable handlers while the tree is populated and then enable back.
    tree->SetEvtHandlerEnabled(false);
    while( node->IsOk() ) {
      var dir = tree->GetItemFullName(node);
      treeAddDir(tree,node,dir);
      node = tree->GetItemParent(node);
    }
    tree->SetEvtHandlerEnabled(true);
  }

  function tree::ActivateItem(item_id) {
    var name = tree->GetItemFullName(item_id);

    var event = wx.wxTreeEvent(wx.wxEVT_COMMAND_TREE_ITEM_ACTIVATED, item_id->GetValue());
    if( PackageEventHandle("onFiletreeActivate", tree, event, item_id) == false ) {
      return;
    }

    // refresh the folder
    if( (tree->IsDirectory(item_id) || tree->IsDirMapped(item_id)) ) {
      if( wx.wxDirExists(name) ) {
        treeAddDir(tree,item_id,name);
        tree->Toggle(item_id);
      } else { refreshAncestors(tree->GetItemParent(item_id)); } // stale content
    } else { // open file
      if( wx.wxFileExists(name) ) { LoadFile(name,null,true);
      } else { refreshAncestors(tree->GetItemParent(item_id)); } // stale content
    }
  }

  function tree::UnmapDirectory(path) {
    var project = ide->GetProject();
    if( ! project ) { return null, "Project is not set"; }

    var dir = wx.wxFileName.DirName(ide->MergePath(project, path));
    var mapped = filetree.settings.mapped[project] || {};
    for( k = #mapped,1,-1 ) {
      if( dir->SameAs(wx.wxFileName.DirName(mapped[k])) ) { table.remove(mapped, k); }
    }
    filetree.settings.mapped[project] = #mapped > 0 && mapped || null;
    saveSettings();
    refreshAncestors(this->GetRootItem());
    return true;
  }
  function tree::MapDirectory(path) {
    var project = ide->GetProject();
    if( ! project ) { return null, "Project is not set"; }

    if( ! path ) {
      var dirPicker = wx.wxDirDialog(ide.frame, TR("Choose a directory to map"),
        project != "" && project || wx.wxGetCwd(), wx.wxDIRP_DIR_MUST_EXIST);
      if( dirPicker->ShowModal(true) != wx.wxID_OK ) { return; }
      var dir = wx.wxFileName.DirName(FixDir(dirPicker->GetPath()));
      // don't remap the project directory
      if( dir->SameAs(wx.wxFileName.DirName(project)) ) { return; }
      path = dir->GetFullPath();
    }

    var dir = wx.wxFileName.DirName(ide->MergePath(project, path));
    if( ! dir->DirExists() ) { return null, "Directory doesn't exist"; }

    var mapped = filetree.settings.mapped[project] || {};
    for( _, m in ipairs(mapped) ) {
      if( dir->SameAs(wx.wxFileName.DirName(m)) ) { return; } // already on the list
    }
    // add to the list; the path includes trailing separator used for directory detection
    table.insert(mapped, dir->GetFullPath());
    filetree.settings.mapped[project] = mapped;
    saveSettings();
    refreshAncestors(this->GetRootItem());
    return true;
  }

  var empty = "";
  var function renameItem(itemsrc, target) {
    var isdir = tree->IsDirectory(itemsrc);
    var isnew = tree->GetItemText(itemsrc) == empty;
    var source = tree->GetItemFullName(itemsrc);
    var fn = wx.wxFileName(target);

    // check if the target is the same as the source;
    // SameAs check is not used here as "Test" and "test" are the same
    // on case insensitive systems, but need to be allowed in renaming.
    if( source == target ) { return; }

    if( PackageEventHandle("onFiletreeFilePreRename", tree, itemsrc, source, target) == false ) {
      return false;
    }

    var docs = {};
    if( ! isnew ) { // find if source is already opened in the editor
      docs = (isdir
        && ide->FindDocumentsByPartialPath(source)
        || {ide->FindDocument(source)});
      for( _, doc in ipairs(docs) ) {
        if( ! isdir && PackageEventHandle("onEditorPreSave", doc.editor, source) == false ) {
          return false;
        }
        if( SaveModifiedDialog(doc.editor, true) == wx.wxID_CANCEL ) { return; }
      }
    }

    // check if existing file/dir is going to be overwritten
    var overwrite = ((wx.wxFileExists(target) || wx.wxDirExists(target))
      && ! wx.wxFileName(source)->SameAs(fn));
    if( overwrite && ! ApproveFileOverwrite() ) { return false; }

    if( ! fn->Mkdir(tonumber(755,8), wx.wxPATH_MKDIR_FULL) ) {
      ide->ReportError(TR("Unable to create directory '%s'.")->format(target));
      return false;
    }

    if( isnew ) { // new directory or file; create manually
      if( (isdir && ! wx.wxFileName.DirName(target)->Mkdir(tonumber(755,8), wx.wxPATH_MKDIR_FULL))
      || (! isdir && ! FileWrite(target, "")) ) {
        ide->ReportError(TR("Unable to create file '%s'.")->format(target));
        return false;
      }
    } else { // existing directory or file; rename/move it
      var ok, err = FileRename(source, target);
      if( ! ok ) {
        ide->ReportError(TR("Unable to rename file '%s'.")->format(source)
          .."\nError: "..err);
        return false;
      }
    }

    refreshAncestors(tree->GetItemParent(itemsrc));
    // load file(s) into the same editor (if any); will also refresh the tree
    if( #docs > 0 ) {
      for( _, doc in ipairs(docs) ) {
        var fullpath = doc.filePath;
        doc.filePath = null; // remove path to avoid "file no longer exists" message
        // when moving folders, /foo/bar/file.ljs can be replaced with
        // /foo/baz/bar/file.ljs, so change /foo/bar to /foo/baz/bar
        var path = (! iscaseinsensitive && fullpath->gsub(q(source), target)
          || fullpath->lower()->gsub(q(source->lower()), target));
        var editor = LoadFile(path);
        // check if the file was loaded into another editor;
        // this is possible if "foo" is renamed to "bar" and both are opened;
        // if this happens, then "bar" is refreshed and "foo" can be closed.
        if( doc.editor->GetId() != editor->GetId() ) { ClosePage(doc.index); }
        if( ! isdir && editor ) { PackageEventHandle("onEditorSave", editor); }
      }
    } else { // refresh the tree and select the new item
      var itemdst = tree->FindItem(target);
      if( itemdst ) {
        tree->UnselectAll();
        refreshAncestors(tree->GetItemParent(itemdst));
        tree->SetFocusedItem(itemdst);
        tree->SelectItem(itemdst);
        tree->EnsureVisible(itemdst);
        tree->SetScrollPos(wx.wxHORIZONTAL, 0, true);
      }
    }

    // refresh the target if it's open and has been overwritten
    if( overwrite && ! isdir ) {
      var doc = ide->FindDocument(target);
      if( doc ) { LoadFile(doc->GetFilePath(), doc->GetEditor()); }
    }

    PackageEventHandle("onFiletreeFileRename", tree, itemsrc, source, target);

    return true;
  }
  var function deleteItem(item_id) {
    // if delete is for mapped directory, unmap it instead
    if( tree->IsDirMapped(item_id) ) {
      tree->UnmapDirectory(tree->GetItemText(item_id));
      return;
    }

    var isdir = tree->IsDirectory(item_id);
    var source = tree->GetItemFullName(item_id);

    if( PackageEventHandle("onFiletreeFilePreDelete", tree, item_id, source) == false ) {
      return false;
    }

    if( isdir && FileDirHasContent(source..pathsep) ) { return false; }
    if( wx.wxMessageBox(
      TR("Do you want to delete '%s'?")->format(source),
      ide->GetProperty("editormessage"),
      wx.wxYES_NO + wx.wxCENTRE, ide.frame) != wx.wxYES ) { return false; }

    if( isdir ) {
      if( ! wx.wxRmdir(source) ) {
        ide->ReportError(TR("Unable to delete directory '%s': %s")
          ->format(source, wx.wxSysErrorMsg()));
      }
    } else {
      var doc = ide->FindDocument(source);
      if( doc ) { ClosePage(doc.index); }
      if( ! wx.wxRemoveFile(source) ) {
        ide->ReportError(TR("Unable to delete file '%s': %s")
          ->format(source, wx.wxSysErrorMsg()));
      }
    }
    refreshAncestors(tree->GetItemParent(item_id));
    PackageEventHandle("onFiletreeFileDelete", tree, item_id, source);
    return true;
  }

  // localizing FileDropTarget doesn't work in wxlua 2.8.13, so keep it in a field
  ide.filetree.filedrop = wx.wxLuaFileDropTarget();
  ide.filetree.filedrop.OnDropFiles = function(this, x, y, filenames) {
    var item_id = tree->HitTest(wx.wxPoint(x,y));
    // set project if one file moved over the project directory
    if( ! tree->GetItemParent(item_id)->IsOk() && #filenames == 1 ) {
      ide->SetProject(filenames[1]);
    } else {
      for( i = 1, #filenames ) { tree->MapDirectory(filenames[i]); }
    }
    return true;
  };
  tree->SetDropTarget(ide.filetree.filedrop);

  tree->Connect(wx.wxEVT_COMMAND_TREE_ITEM_COLLAPSED,
    function (event) {
      PackageEventHandle("onFiletreeCollapse", tree, event, event->GetItem());
    });
  tree->Connect(wx.wxEVT_COMMAND_TREE_ITEM_EXPANDED,
    function (event) {
      PackageEventHandle("onFiletreeExpand", tree, event, event->GetItem());
    });
  tree->Connect(wx.wxEVT_COMMAND_TREE_ITEM_COLLAPSING,
    function (event) {
      if( PackageEventHandle("onFiletreePreCollapse", tree, event, event->GetItem()) == false ) {
        return;
      }
    });
  tree->Connect(wx.wxEVT_COMMAND_TREE_ITEM_EXPANDING,
    function (event) {
      var item_id = event->GetItem();
      if( PackageEventHandle("onFiletreePreExpand", tree, event, item_id) == false ) {
        return;
      }

      var dir = tree->GetItemFullName(item_id);
      if( wx.wxDirExists(dir) ) { treeAddDir(tree,item_id,dir); // refresh folder
      } else { refreshAncestors(tree->GetItemParent(item_id)); } // stale content
      return true;
    });
  tree->Connect(wx.wxEVT_COMMAND_TREE_ITEM_ACTIVATED,
    function (event) {
      tree->ActivateItem(event->GetItem());
    });

  // refresh the tree
  var function refreshChildren() {
    tree->RefreshChildren();
    // now mark the current file (if it was previously disabled)
    var editor = ide->GetEditor();
    if( editor ) { FileTreeMarkSelected(ide->GetDocument(editor)->GetFilePath()); }
  }

  // handle context menu
  var function addItem(item_id, name, img) {
    var isdir = tree->IsDirectory(item_id);
    var parent = isdir && item_id || tree->GetItemParent(item_id);
    if( isdir ) { tree->Expand(item_id); } // expand to populate if needed

    var item = tree->PrependItem(parent, name, img);
    tree->SetItemHasChildren(parent, true);
    // temporarily disable expand as we don't need this node populated
    tree->SetEvtHandlerEnabled(false);
    tree->EnsureVisible(item);
    tree->SetEvtHandlerEnabled(true);
    return item;
  }

  var function unsetStartFile() {
    var project = ide->GetProject();
    if( ! project ) { return; }

    var startfile = filetree.settings.startfile[project];
    filetree.settings.startfile[project] = null;
    if( startfile ) {
      var item_id = tree->FindItem(startfile);
      if( item_id && item_id->IsOk() ) {
        tree->SetItemImage(item_id, getIcon(tree->GetItemFullName(item_id)));
      }
    }
    return startfile;
  }

  var function setStartFile(item_id) {
    var project = ide->GetProject();
    if( ! project ) { return; }

    var startfile = tree->GetItemFullName(item_id)->gsub(q(project), "");
    filetree.settings.startfile[project] = startfile;
    tree->SetItemImage(item_id, getIcon(tree->GetItemFullName(item_id)));
    return startfile;
  }

  function tree::GetStartFile() {
    var project = ide->GetProject();
    return project && filetree.settings.startfile[project];
  }

  function tree::SetStartFile(path) {
    var item_id;
    var project = ide->GetProject();
    if( project && type(path) == "string" ) {
      var startfile = path->gsub(q(project), "");
      item_id = this->FindItem(startfile);
    }
    // unset if explicitly requested or the replacement has been found
    if( ! path || item_id ) { unsetStartFile(); }
    if( item_id ) { setStartFile(item_id); }

    saveSettings();
    return item_id;
  }

  tree->Connect(ID.NEWFILE, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      tree->EditLabel(addItem(tree->GetFocusedItem(), empty, image.FILEOTHER));
    });
  tree->Connect(ID.NEWDIRECTORY, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      tree->EditLabel(addItem(tree->GetFocusedItem(), empty, image.DIRECTORY));
    });
  tree->Connect(ID.RENAMEFILE, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() { tree->EditLabel(tree->GetFocusedItem()); });
  tree->Connect(ID.DELETEFILE, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() { deleteItem(tree->GetFocusedItem()); });
  tree->Connect(ID.COPYFULLPATH, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() { ide->CopyToClipboard(tree->GetItemFullName(tree->GetFocusedItem())); });
  tree->Connect(ID.OPENEXTENSION, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      var fname = tree->GetItemFullName(tree->GetFocusedItem());
      var ext = '.'..wx.wxFileName(fname)->GetExt();
      var ft = wx.wxTheMimeTypesManager->GetFileTypeFromExtension(ext);
      if( ft ) {
        var cmd = ft->GetOpenCommand(fname->gsub('"','\\"'));
        // some programs on Windows, when started by rundll32.exe (for example, PhotoViewer)
        // accept files with spaces in names ONLY if they are not in quotes.
        if( ide.osname == "Windows" && cmd->find("rundll32%.exe") ) {
          cmd = ft->GetOpenCommand("")->gsub('""%s*$', '')..fname;
        }
        wx.wxExecute(cmd, wx.wxEXEC_ASYNC);
      }
    });
  tree->Connect(ID.REFRESH, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() { refreshChildren(); });
  tree->Connect(ID.SHOWLOCATION, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() { ShowLocation(tree->GetItemFullName(tree->GetFocusedItem())); });
  tree->Connect(ID.HIDEEXTENSION, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      var ext = GetFileExt(tree->GetItemText(tree->GetFocusedItem()));
      filetree.settings.extensionignore[ext] = true;
      saveSettings();
      refreshChildren();
    });
  tree->Connect(ID.SHOWEXTENSIONALL, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      filetree.settings.extensionignore = {};
      saveSettings();
      refreshChildren();
    });
  tree->Connect(ID.SETSTARTFILE, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      tree->SetStartFile(tree->GetItemFullName(tree->GetFocusedItem()));
    });
  tree->Connect(ID.UNSETSTARTFILE, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      tree->SetStartFile();
    });
  tree->Connect(ID.MAPDIRECTORY, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      tree->MapDirectory();
    });
  tree->Connect(ID.UNMAPDIRECTORY, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      tree->UnmapDirectory(tree->GetItemText(tree->GetFocusedItem()));
    });
  tree->Connect(ID.PROJECTDIRFROMDIR, wx.wxEVT_COMMAND_MENU_SELECTED,
    function() {
      ide->SetProject(tree->GetItemFullName(tree->GetFocusedItem()));
    });

  tree->Connect(wx.wxEVT_COMMAND_TREE_ITEM_MENU,
    function (event) {
      var item_id = event->GetItem();
      tree->SetFocusedItem(item_id);

      var renamelabel = (tree->IsRoot(item_id)
        && TR("&Edit Project Directory")
        || TR("&Rename"));
      var fname = tree->GetItemText(item_id);
      var ext = GetFileExt(fname);
      var project = ide->GetProject();
      var startfile = project && filetree.settings.startfile[project];
      var menu = ide->MakeMenu ({
        { ID.NEWFILE, TR("New &File") },
        { ID.NEWDIRECTORY, TR("&New Directory") },
        { },
        { ID.RENAMEFILE, renamelabel..KSC(ID.RENAMEFILE) },
        { ID.DELETEFILE, TR("&Delete")..KSC(ID.DELETEFILE) },
        { ID.REFRESH, TR("Refresh") },
        { },
        { ID.HIDEEXTENSION, TR("Hide '.%s' Files")->format(ext) },
        { },
        { ID.SETSTARTFILE, TR("Set As Start File") },
        { ID.UNSETSTARTFILE, TR("Unset '%s' As Start File")->format(startfile || "<none>") },
        { },
        { ID.MAPDIRECTORY, TR("Map Directory...") },
        { ID.UNMAPDIRECTORY, TR("Unmap Directory") },
        { ID.OPENEXTENSION, TR("Open With Default Program") },
        { ID.COPYFULLPATH, TR("Copy Full Path") },
        { ID.SHOWLOCATION, TR("Show Location") },
      });
      var extlist = {
        {},
        { ID.SHOWEXTENSIONALL, TR("Show All Files"), TR("Show all files") },
      };
      for( extignore in pairs(filetree.settings.extensionignore) ) {
        var id = ID("filetree.showextension."..extignore);
        table.insert(extlist, 1, {id, '.'..extignore});
        menu->Connect(id, wx.wxEVT_COMMAND_MENU_SELECTED, function() {
          filetree.settings.extensionignore[extignore] = null;
          saveSettings();
          refreshChildren();
        });
      }
      var _, _, hideextpos = ide->FindMenuItem(ID.HIDEEXTENSION, menu);
      assert(hideextpos, "Can't find HideExtension menu item");
      menu->Insert(hideextpos+1, wx.wxMenuItem(menu, ID.SHOWEXTENSION,
        TR("Show Hidden Files"), TR("Show files previously hidden"),
        wx.wxITEM_NORMAL, ide->MakeMenu(extlist)));

      var projectdirectorymenu = ide->MakeMenu ({
        { },
        {ID.PROJECTDIRCHOOSE, TR("Choose...")..KSC(ID.PROJECTDIRCHOOSE), TR("Choose a project directory")},
        {ID.PROJECTDIRFROMDIR, TR("Set To Selected Directory")..KSC(ID.PROJECTDIRFROMDIR), TR("Set project directory to the selected one")},
      });
      var projectdirectory = wx.wxMenuItem(menu, ID.PROJECTDIR,
        TR("Project Directory"), TR("Set the project directory to be used"),
        wx.wxITEM_NORMAL, projectdirectorymenu);
      var _, _, unmapdirpos = ide->FindMenuItem(ID.UNMAPDIRECTORY, menu);
      assert(unmapdirpos, "Can't find UnMapDirectory menu item");
      menu->Insert(unmapdirpos+1, projectdirectory);
      FileTreeProjectListUpdate(projectdirectorymenu, 0);

      // disable Delete on non-empty directories
      var isdir = tree->IsDirectory(item_id);
      var ismapped = tree->IsDirMapped(item_id);
      menu->Destroy(ismapped && ID.MAPDIRECTORY || ID.UNMAPDIRECTORY);
      if( ! startfile ) { menu->Destroy(ID.UNSETSTARTFILE); }
      if( ismapped ) { menu->Enable(ID.RENAMEFILE, false); }
      if( isdir ) {
        var source = tree->GetItemFullName(item_id);
        menu->Enable(ID.DELETEFILE, ! FileDirHasContent(source..pathsep));
        menu->Enable(ID.OPENEXTENSION, false);
        menu->Enable(ID.HIDEEXTENSION, false);
      } else {
        var ft = wx.wxTheMimeTypesManager->GetFileTypeFromExtension('.'..ext);
        menu->Enable(ID.OPENEXTENSION, ft && #ft->GetOpenCommand("") > 0);
        menu->Enable(ID.HIDEEXTENSION, ! filetree.settings.extensionignore[ext]);
        menu->Enable(ID.PROJECTDIRFROMDIR, false);
      }
      menu->Enable(ID.SETSTARTFILE, tree->IsFileOther(item_id) || tree->IsFileKnown(item_id));
      menu->Enable(ID.SHOWEXTENSION, next(filetree.settings.extensionignore) != null);

      PackageEventHandle("onMenuFiletree", menu, tree, event);

      // stopping/restarting garbage collection is generally not needed,
      // but on Linux not stopping is causing crashes (wxwidgets 2.9.5 and 3.1.0)
      // when symbol indexing is done while popup menu is open (with gc methods in the trace).
      // this only happens when EVT_IDLE is called when popup menu is open.
      collectgarbage("stop");

      // stopping UI updates is generally not needed as well,
      // but it's causing a crash on OSX (wxwidgets 2.9.5 and 3.1.0)
      // when symbol indexing is done while popup menu is open, so it's disabled
      var interval = wx.wxUpdateUIEvent.GetUpdateInterval();
      wx.wxUpdateUIEvent.SetUpdateInterval(-1); // don't update

      tree->PopupMenu(menu);
      wx.wxUpdateUIEvent.SetUpdateInterval(interval);
      collectgarbage("restart");
    });

  tree->Connect(wx.wxEVT_RIGHT_DOWN,
    function (event) {
      var item_id = tree->HitTest(event->GetPosition());
      if( PackageEventHandle("onFiletreeRDown", tree, event, item_id && item_id->IsOk() && item_id || null) == false ) {
        return;
      }
      event->Skip();
    });

  // toggle a folder on a single click
  tree->Connect(wx.wxEVT_LEFT_DOWN,
    function (event) {
      // only toggle if this is a folder and the click is on the item line
      // (exclude the label as it's used for renaming and dragging)
      var mask = (wx.wxTREE_HITTEST_ONITEMINDENT
        + wx.wxTREE_HITTEST_ONITEMICON + wx.wxTREE_HITTEST_ONITEMRIGHT);
      var item_id, flags = tree->HitTest(event->GetPosition());

      if( PackageEventHandle("onFiletreeLDown", tree, event, item_id && item_id->IsOk() && item_id || null) == false ) {
        return;
      }

      if( item_id && item_id->IsOk() && bit.band(flags, mask) > 0 ) {
        if( tree->IsDirectory(item_id) ) {
          tree->Toggle(item_id);
        } else {
          var name = tree->GetItemFullName(item_id);
          if( wx.wxFileExists(name) ) { LoadFile(name,null,true); }
        }
      } else {
        event->Skip();
      }
      return true;
    });
  var parent;
  tree->Connect(wx.wxEVT_COMMAND_TREE_BEGIN_LABEL_EDIT,
    function (event) {
      var itemsrc = event->GetItem();
      parent = tree->GetItemParent(itemsrc);
      if( ! itemsrc->IsOk() || tree->IsDirMapped(itemsrc) ) { event->Veto(); }
    });
  tree->Connect(wx.wxEVT_COMMAND_TREE_END_LABEL_EDIT,
    function (event) {
      // veto the event to keep the original label intact as the tree
      // is going to be refreshed with the correct names.
      event->Veto();

      var itemsrc = event->GetItem();
      if( ! itemsrc->IsOk() ) { return; }

      var label = event->GetLabel()->gsub("^%s+$",""); // clean all spaces

      // edited the root element; set the new project directory if needed
      var cancelled = event->IsEditCancelled();
      if( tree->IsRoot(itemsrc) ) {
        if( ! cancelled && wx.wxDirExists(label) ) {
          ide->SetProject(label);
        }
        return;
      }

      if( ! parent || ! parent->IsOk() ) { return; }
      var target = MergeFullPath(tree->GetItemFullName(parent), label);
      if( cancelled || label == empty ) { refreshAncestors(parent);
      } else if( target ) {
        // wxwidgets v2.9.5 and earlier crashes when the IDE loses focus
        // during renaming a file that has a conflict with an exising one
        // (caused by the same END_LABEL_EDIT even triggered one more time).
        if( ide.osname == "Linux" && ide.wxver <= "2.9.5" ) { return; }
        if( ! renameItem(itemsrc, target) ) { refreshAncestors(parent); }
      }
    });

  var itemsrc;
  tree->Connect(wx.wxEVT_COMMAND_TREE_BEGIN_DRAG,
    function (event) {
      if( ide.config.filetree.mousemove && tree->GetItemParent(event->GetItem())->IsOk() ) {
        itemsrc = event->GetItem();
        event->Allow();
      }
    });
  tree->Connect(wx.wxEVT_COMMAND_TREE_END_DRAG,
    function (event) {
      var itemdst = event->GetItem();
      if( ! itemdst->IsOk() || ! itemsrc->IsOk() ) { return; }

      // check if itemdst is a folder
      var target = tree->GetItemFullName(itemdst);
      if( wx.wxDirExists(target) ) {
        var source = tree->GetItemFullName(itemsrc);
        // check if moving the directory and target is a subfolder of source
        if( (target..pathsep)->find("^"..q(source)..pathsep) ) { return; }
        renameItem(itemsrc, MergeFullPath(target, tree->GetItemText(itemsrc)));
      }
    });
}

// project
var projtree = ide->CreateTreeCtrl(ide.frame, wx.wxID_ANY,
  wx.wxDefaultPosition, wx.wxDefaultSize,
  wx.wxTR_HAS_BUTTONS + wx.wxTR_MULTIPLE + wx.wxTR_LINES_AT_ROOT
  + wx.wxTR_EDIT_LABELS + wx.wxNO_BORDER);
projtree->SetFont(ide.font.tree);
filetree.projtreeCtrl = projtree;

ide->GetProjectNotebook()->AddPage(projtree, TR("Project"), true);

// proj connectors
// ---------------

treeSetConnectorsAndIcons(projtree);

// proj functions
// ---------------

var function appendPathSep(dir) {
  return (dir && #dir > 0 && wx.wxFileName.DirName(dir)->GetFullPath() || null);
}

function filetree::updateProjectDir(newdir) {
  if( (! newdir) || ! wx.wxDirExists(newdir) ) { return null, "Directory doesn't exist"; }
  var dirname = wx.wxFileName.DirName(newdir);

  if( filetree.projdir && #filetree.projdir > 0
  && dirname->SameAs(wx.wxFileName.DirName(filetree.projdir)) ) { return false; }

  // strip the last path separator if any
  newdir = dirname->GetPath(wx.wxPATH_GET_VOLUME);

  // save the current interpreter as it may be reset in onProjectClose
  // when the project event handlers manipulates interpreters
  var intfname = ide.interpreter && ide.interpreter.fname;

  if( filetree.projdir && #filetree.projdir > 0 ) {
    PackageEventHandle("onProjectClose", appendPathSep(filetree.projdir));
  }

  PackageEventHandle("onProjectPreLoad", appendPathSep(newdir));

  if( ide.config.projectautoopen && filetree.projdir ) {
    StoreRestoreProjectTabs(filetree.projdir, newdir, intfname);
  }

  filetree.projdir = newdir;
  filetree.projdirpartmap = {};

  PrependStringToArray(
    filetree.projdirlist,
    newdir,
    ide.config.projecthistorylength,
    function(s1, s2) { return dirname->SameAs(wx.wxFileName.DirName(s2)); });

  ide->SetProject(newdir,true);
  treeSetRoot(projtree,newdir);

  // sync with the current editor window and activate selected file
  var editor = ide->GetEditor();
  if( editor ) { FileTreeMarkSelected(ide->GetDocument(editor)->GetFilePath()); }

  // refresh Recent Projects menu item
  ide.frame->AddPendingEvent(wx.wxUpdateUIEvent(ID.RECENTPROJECTS));

  PackageEventHandle("onProjectLoad", appendPathSep(newdir));

  return true;
}

function FileTreeSetProjects(tab) {
  filetree.projdirlist = tab;
  if( (tab && tab[1]) ) {
    filetree->updateProjectDir(tab[1]);
  }
}

function FileTreeGetProjects() { return filetree.projdirlist; }

var function getProjectLabels() {
  var labels = {};
  var fmt = ide.config.format.menurecentprojects || '%f';
  for( _, proj in ipairs(FileTreeGetProjects()) ) {
    var config = ide.session.projects[proj];
    var intfname = config && config[2] && config[2].interpreter || ide.interpreter->GetFileName();
    var interpreter = intfname && ide.interpreters[intfname];
    var parts = wx.wxFileName(proj..pathsep)->GetDirs();
    table.insert(labels, ide->ExpandPlaceholders(fmt, {
          f = proj,
          i = interpreter && interpreter->GetName() || (intfname || '')..'?',
          s = parts[#parts] || '',
        }));
  }
  return labels;
}

function FileTreeProjectListClear() {
  // remove all items from the list except the current one
  filetree.projdirlist = {ide->GetProject()};
}

function FileTreeProjectListUpdate(menu, items) {
  // protect against recent project menu not being present
  if( ! ide->FindMenuItem(ID.RECENTPROJECTS) ) { return; }

  var list = getProjectLabels();
  for( i=#list, 1, -1 ) {
    var id = ID("file.recentprojects."..i);
    var label = list[i];
    if( i <= items ) { // this is an existing item; update the label
      menu->FindItem(id)->SetItemLabel(label);
    } else { // need to add an item
      var item = wx.wxMenuItem(menu, id, label, "");
      menu->Insert(items, item);
      ide.frame->Connect(id, wx.wxEVT_COMMAND_MENU_SELECTED, function() {
          wx.wxSafeYield(); // let the menu on screen (if any) disappear
          ide->SetProject(FileTreeGetProjects()[i]);
        });
    }
    // disable the currently selected project
    if( i == 1 ) { menu->Enable(id, false); }
  }
  for( i=items, #list+1, -1 ) { // delete the rest if the list got shorter
    menu->Delete(menu->FindItemByPosition(i-1));
  }
  return #list;
}

var curr_file;
function FileTreeMarkSelected(file) {
  if( ! file || ! filetree.projdir || #filetree.projdir == 0
  || ! ide->IsValidCtrl(projtree) ) { return; }

  var item_id = wx.wxIsAbsolutePath(file) && projtree->FindItem(file);

  // if the select item is different from the current one
  // or the current one is the same, but not bold (which may happen when
  // the project is changed to one that includes the current item)
  if( curr_file != file
  || item_id && ! projtree->IsBold(item_id) ) {
    if( curr_file ) {
      var curr_id = wx.wxIsAbsolutePath(curr_file) && projtree->FindItem(curr_file);
      if( curr_id && projtree->IsBold(curr_id) ) {
        projtree->SetItemBold(curr_id, false);
      }
    }
    if( item_id ) {
      projtree->EnsureVisible(item_id);
      projtree->SetScrollPos(wx.wxHORIZONTAL, 0, true);
      projtree->SetItemBold(item_id, true);
    }
    curr_file = file;
    if( ide.wxver < "2.9.5" && ide.osname == 'Macintosh' ) {
      projtree->Refresh();
    }
  }
}

function FileTreeFindByPartialName(name) {
  // check if it's already cached
  if( filetree.projdirpartmap[name] ) { return filetree.projdirpartmap[name]; }

  // this function may get a partial name that starts with ... and has
  // an abbreviated path (as generated by stack traces);
  // remove starting "..." if any and escape
  var pattern = q(name->gsub("^%.%.%.",""))->gsub("[\\/]", "[\\/]").."$";
  var lpattern = pattern->lower();

  for( _, file in ipairs(ide->GetFileList(filetree.projdir, true)) ) {
    if( file->find(pattern) || iscaseinsensitive && file->lower()->find(lpattern) ) {
      filetree.projdirpartmap[name] = file;
      return file;
    }
  }
  return;
}

var watchers, blacklist, watcher = {}, {};
var function watchDir(path) {
  if( watcher && ! watchers[path] && ! blacklist[path] ) {
    var _ = wx.wxLogNull(); // disable error reporting; will report as needed
    var ok  = watcher->Add(wx.wxFileName.DirName(path),
      wx.wxFSW_EVENT_CREATE + wx.wxFSW_EVENT_DELETE + wx.wxFSW_EVENT_RENAME);
    if( ! ok ) {
      blacklist[path] = true;
      ide->GetOutput()->Error(("Can't set watch for '%s': %s")->format(path, wx.wxSysErrorMsg()));
      return null, wx.wxSysErrorMsg();
    }
  }
  // keep track of watchers even if `watcher` is not yet set to set them later
  watchers[path] = watcher != null;
  return watchers[path];
}
var function unWatchDir(path) {
  if( watcher && watchers[path] ) { watcher->Remove(wx.wxFileName.DirName(path)); }
  watchers[path] = null;
}
var package = ide->AddPackage('core.filetree', {
    onProjectClose = function(plugin, project) {
      if( watcher ) { watcher->RemoveAll(); }
      watchers = {};
    },

    // watcher can only be properly setup when MainLoop is already running, so use first idle event
    onIdleOnce = function(plugin) {
      if( ! ide.config.filetree.showchanges || ! wx.wxFileSystemWatcher ) { return; }
      if( ! watcher ) {
        watcher = wx.wxFileSystemWatcher();
        watcher->SetOwner(ide->GetMainFrame());

        var needrefresh = {};
        ide->GetMainFrame()->Connect(wx.wxEVT_FSWATCHER, function(event) {
            // using `GetNewPath` to make it work with rename operations
            needrefresh[event->GetNewPath()->GetFullPath()] = event->GetChangeType();
            ide->DoWhenIdle(function() {
                for( file, kind in pairs(needrefresh) ) {
                  // if the file is removed, try to find a non-existing file in the same folder
                  // as this will trigger a refresh of that folder
                  var path = MergeFullPath(file, kind == wx.wxFSW_EVENT_DELETE && "../\1"  || "");
                  var tree = ide->GetProjectTree(); // project tree may be hidden/disabled
                  if( ide->IsValidCtrl(tree) ) { tree->FindItem(path); }
                }
                needrefresh = {};
              });
          });
      }
      // start watching cached paths
      for( path, active in pairs(watchers) ) {
        if( ! active ) { watchDir(path); }
      }
    },

    // check on PreExpand when expanding (as the folder may not expand if it's empty)
    onFiletreePreExpand = function(plugin, tree, event, item_id) {
      watchDir(tree->GetItemFullName(item_id));
    },

    // check on Collapse when collapsing to make sure it's unwatched only when collapsed
    onFiletreeCollapse = function(plugin, tree, event, item_id) {
      // only unwatch if the directory is not empty;
      // otherwise it's collapsed without ability to expand
      if( tree->GetChildrenCount(item_id, false) > 0 ) { unWatchDir(tree->GetItemFullName(item_id)); }
    },
  });
MergeSettings(filetree.settings, package->GetSettings());
