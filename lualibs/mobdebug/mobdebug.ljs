//
// MobDebug -- Lua remote debugger
// Copyright 2011-18 Paul Kulchenko
// Based on RemDebug 1.0 Copyright Kepler Project 2005
//

// use loaded modules or load explicitly on those systems that require that
var require = require;
var io = io || require ("io");
var table = table || require ("table");
var string = string || require ("string");
var coroutine = coroutine || require ("coroutine");
var debug = require ("debug");
// protect require "os" as it may fail on embedded systems without os module
var os = os || (function(module) {
  var ok, res = pcall(require, module);
  return ok && res || null;
})("os");

var mobdebug = {
  _NAME = "mobdebug",
  _VERSION = "0.705",
  _COPYRIGHT = "Paul Kulchenko",
  _DESCRIPTION = "Mobile Remote Debugger for the Lua programming language",
  port = os && os.getenv && tonumber((os.getenv("MOBDEBUG_PORT"))) || 8172,
  checkcount = 200,
  yieldtimeout = 0.02, // yield timeout (s)
  connecttimeout = 2, // connect timeout (s)
};

var HOOKMASK = "lcr";
var error = error;
var getfenv = getfenv;
var setfenv = setfenv;
var loadstring = loadstring || load; // "load" replaced "loadstring" in Lua 5.2
var pairs = pairs;
var setmetatable = setmetatable;
var tonumber = tonumber;
var unpack = table.unpack || unpack;
var rawget = rawget;
var gsub, sub, find = string.gsub, string.sub, string.find;

// if strict.ljs is used, then need to avoid referencing some global
// variables, as they can be undefined;
// use rawget to avoid complaints from strict.ljs at run-time.
// it's safe to do the initialization here as all these variables
// should get defined values (if any) before the debugging starts.
// there is also global 'wx' variable, which is checked as part of
// the debug loop as 'wx' can be loaded at any time during debugging.
var genv = _G || _ENV;
var jit = rawget(genv, "jit");
var MOAICoroutine = rawget(genv, "MOAICoroutine");

// ngx_lua debugging requires a special handling as its coroutine.*
// methods use a different mechanism that doesn't allow resume calls
// from debug hook handlers.
// Instead, the "original" coroutine.* methods are used.
// `rawget` needs to be used to protect against `strict` checks, but
// ngx_lua hides those in a metatable, so need to use that.
var metagindex = getmetatable(genv) && getmetatable(genv).__index;
var ngx = type(metagindex) == "table" && metagindex.rawget && metagindex->rawget("ngx") || null;
var corocreate = ngx && coroutine._create || coroutine.create;
var cororesume = ngx && coroutine._resume || coroutine.resume;
var coroyield = ngx && coroutine._yield || coroutine.yield;
var corostatus = ngx && coroutine._status || coroutine.status;
var corowrap = coroutine.wrap;

if( ! setfenv ) { // Lua 5.2+
  // based on http://lua-users.org/lists/lua-l/2010-06/msg00314.html
  // this assumes f is a function
  var function findenv(f) {
    var level = 1;
    do {
      var name, value = debug.getupvalue(f, level);
      if( name == '_ENV' ) { return level, value; }
      level +=   1;
    } while(!( name == null) );
    return null; }
  getfenv = function (f) { return(select(2, findenv(f)) || _G); };
  setfenv = function (f, t) {
    var level = findenv(f);
    if( level ) { debug.setupvalue(f, level, t); }
    return f; };
}

// check for OS and convert file names to lower case on windows
// (its file system is case insensitive, but case preserving), as setting a
// breakpoint on x:\Foo.ljs will not work if the file was loaded as X:\foo.ljs.
// OSX and Windows behave the same way (case insensitive, but case preserving).
// OSX can be configured to be case-sensitive, so check for that. This doesn't
// handle the case of different partitions having different case-sensitivity.
var win = os && os.getenv && (os.getenv('WINDIR') || (os.getenv('OS') || '')->match('[Ww]indows')) && true || false;
var mac = ! win && (os && os.getenv && os.getenv('DYLD_LIBRARY_PATH') || ! io.open("/proc")) && true || false;
var iscasepreserving = win || (mac && io.open('/library') != null);

// turn jit off based on Mike Pall's comment in this discussion:
// http://www.freelists.org/post/luajit/Debug-hooks-and-JIT,2
// "You need to turn it off at the start if you plan to receive
// reliable hook calls at any later point in time."
if( jit && jit.off ) { jit.off(); }

var socket = require ("socket");
var coro_debugger;
var coro_debugee;
var coroutines = {}; setmetatable(coroutines, {__mode = "k"}); // "weak" keys
var events = { BREAK = 1, WATCH = 2, RESTART = 3, STACK = 4 };
var breakpoints = {};
var watches = {};
var lastsource;
var lastfile;
var watchescnt = 0;
var abort; // default value is nil; this is used in start/loop distinction
var seen_hook = false;
var checkcount = 0;
var step_into = false;
var step_over = false;
var step_level = 0;
var stack_level = 0;
var server;
var buf;
var outputs = {};
var iobase = {print = print};
var basedir = "";
var deferror = "execution aborted at default debugee";
var debugee = function () {
  var a = 1;
  for( _ = 1, 10 ) { a +=   1; }
  error(deferror);
};
var function q(s) { return string.gsub(s, '([%(%)%.%%%+%-%*%?%[%^%$%]])','%%%1'); }

var serpent = (function() { //-- include Serpent module for serialization
var n, v = "serpent", "0.302"; // (C) 2012-18 Paul Kulchenko; MIT License
var c, d = "Paul Kulchenko", "Lua serializer and pretty printer";
var snum = {[tostring(1/0)]='1/0 /*=math.huge=*/',[tostring(-1/0)]='-1/0 /*=-math.huge=*/',[tostring(0/0)]='0/0'};
var badtype = {thread = true, userdata = true, cdata = true};
var getmetatable = debug && debug.getmetatable || getmetatable;
var pairs = function(t) { return next, t; }; // avoid using __pairs in Lua 5.2+
var keyword, globals, G = {}, {}, (_G || _ENV);
for( _,k in ipairs({'auto', 'break', 'continue', 'do', 'else', 'false', '__FILE__',
  'for', 'function', 'goto', 'if', 'in', 'let', 'local', 'null', 'let', '__LINE__',
  'return', 'true', 'var', 'while'}) ) { keyword[k] = true; }
for( k,v in pairs(G) ) { globals[v] = k; } // build func to name mapping
for( _,g in ipairs({'coroutine', 'debug', 'io', 'math', 'string', 'table', 'os'}) ) {
  for( k,v in pairs(type(G[g]) == 'table' && G[g] || {}) ) { globals[v] = g..'.'..k; } }

var function s(t, opts) {
  var name, indent, fatal, maxnum = opts.name, opts.indent, opts.fatal, opts.maxnum;
  var sparse, custom, huge = opts.sparse, opts.custom, ! opts.nohuge;
  var space, maxl = (opts.compact && '' || ' '), (opts.maxlevel || math.huge);
  var maxlen, metatostring = tonumber(opts.maxlength), opts.metatostring;
  var iname, comm = '_'..(name || ''), opts.comment && (tonumber(opts.comment) || math.huge);
  var numformat = opts.numformat || "%.17g";
  var seen, sref, syms, symn = {}, {'var '..iname..'={}'}, {}, 0;
  var function gensym(val) { return '_'..(tostring(tostring(val))->gsub("[^%w]","")->gsub("(%d%w+)",
    // tostring(val) is needed because __tostring may return a non-string value
    function(s) { if( ! syms[s] ) { symn += 1; syms[s] = symn; } return tostring(syms[s]); })); }
  var function safestr(s) { return type(s) == "number" && tostring(huge && snum[tostring(s)] || numformat->format(s))
    || type(s) != "string" && tostring(s) // escape NEWLINE/010 and EOF/026
    || ("%q")->format(s)->gsub("\010","n")->gsub("\026","\\026"); }
  var function comment(s,l) { return comm && (l || 0) < comm && ' /*='..select(2, pcall(tostring, s))..'=*/' || ''; }
  var function globerr(s,l) { return globals[s] && globals[s]..comment(s,l) || ! fatal
    && safestr(select(2, pcall(tostring, s))) || error("Can't serialize "..tostring(s)); }
  var function safename(path, name) { // generates foo.bar, foo[3], or foo['b a r']
    var n = name == null && '' || name;
    var plain = type(n) == "string" && n->match("^[%l%u_][%w_]*$") && ! keyword[n];
    var safe = plain && n || '['..safestr(n)..']';
    return (path || '')..(plain && path && '.' || '')..safe, safe; }
  var alphanumsort = type(opts.sortkeys) == 'function' && opts.sortkeys || function(k, o, n) { // k=keys, o=originaltable, n=padding
    var maxn, to = tonumber(n) || 12, {number = 'a', string = 'b'};
    var function padnum(d) { return ("%0"..tostring(maxn).."d")->format(tonumber(d)); }
    table.sort(k, function(a,b) {
      // sort numeric keys first: k[key] is not nil for numerical keys
      return (k[a] != null && 0 || to[type(a)] || 'z')..(tostring(a)->gsub("%d+",padnum))
           < (k[b] != null && 0 || to[type(b)] || 'z')..(tostring(b)->gsub("%d+",padnum)); }); };
  var function val2str(t, name, indent, insref, path, plainindex, level) {
    var ttype, mt;
    ttype, level, mt = type(t), (level || 0), getmetatable(t);
    var spath, sname = safename(path, name);
    var tag = plainindex &&
      ((type(name) == "number") && '' || name..space..'='..space) ||
      (name != null && sname..space..'='..space || '');
    if( seen[t] ) { // already seen this element
      sref[#sref+1] = spath..space..'='..space..seen[t];
      return tag..'null'..comment('ref', level); }
    // protect from those cases where __tostring may fail
    if( type(mt) == 'table' && metatostring != false ) {
      var to, tr = pcall(function() { return mt.__tostring(t); });
      var so, sr = pcall(function() { return mt.__serialize(t); });
      if( (to || so) ) { // knows how to serialize itself
        seen[t] = insref || spath;
        t = so && sr || tr;
        ttype = type(t);
      } // new value falls through to be serialized
    }
    if( ttype == "table" ) {
      if( level >= maxl ) { return tag..'{}'..comment('maxlvl', level); }
      seen[t] = insref || spath;
      if( next(t) == null ) { return tag..'{}'..comment(t, level); } // table empty
      if( maxlen && maxlen < 0 ) { return tag..'{}'..comment('maxlen', level); }
      var maxn, o, out = math.min(#t, maxnum || #t), {}, {};
      for( key = 1, maxn ) { o[key] = key; }
      if( ! maxnum || #o < maxnum ) {
        var n = #o; // n = n + 1; o[n] is much faster than o[#o+1] on large tables
        for( key in pairs(t) ) { if( o[key] != key ) { n +=   1; o[n] = key; } } }
      if( maxnum && #o > maxnum ) { o[maxnum+1] = null; }
      if( opts.sortkeys && #o > maxn ) { alphanumsort(o, t, opts.sortkeys); }
      var sparse = sparse && #o > maxn; // disable sparsness if only numeric keys (shorter output)
      for( n, key in ipairs(o) ) {
        var value, ktype, plainindex = t[key], type(key), n <= maxn && ! sparse;
        if( opts.valignore && opts.valignore[value] // skip ignored values; do nothing
        || opts.keyallow && ! opts.keyallow[key]
        || opts.keyignore && opts.keyignore[key]
        || opts.valtypeignore && opts.valtypeignore[type(value)] // skipping ignored value types
        || sparse && value == null ) { // skipping nils; do nothing
        } else if( ktype == 'table' || ktype == 'function' || badtype[ktype] ) {
          if( ! seen[key] && ! globals[key] ) {
            sref[#sref+1] = 'placeholder';
            var sname = safename(iname, gensym(key)); // iname is table for local variables
            sref[#sref] = val2str(key,sname,indent,sname,iname,true); }
          sref[#sref+1] = 'placeholder';
          var path = seen[t]..'['..tostring(seen[key] || globals[key] || gensym(key))..']';
          sref[#sref] = path..space..'='..space..tostring(seen[value] || val2str(value,null,indent,path));
        } else {
          out[#out+1] = val2str(value,key,indent,null,seen[t],plainindex,level+1);
          if( maxlen ) {
            maxlen -=   #out[#out];
            if( maxlen < 0 ) { break; }
          }
        }
      }
      var prefix = string.rep(indent || '', level);
      var head = indent && '{\n'..prefix..indent || '{';
      var body = table.concat(out, ','..(indent && '\n'..prefix..indent || space));
      var tail = indent && "\n"..prefix..'}' || '}';
      return (custom && custom(tag,head,body,tail,level) || tag..head..body..tail)..comment(t, level);
    } else if( badtype[ttype] ) {
      seen[t] = insref || spath;
      return tag..globerr(t, level);
    } else if( ttype == 'function' ) {
      seen[t] = insref || spath;
      if( opts.nocode ) { return tag.."function() {/*=..skipped..=*/ }"..comment(t, level); }
      var ok, res = pcall(string.dump, t);
      var func = ok && "((loadstring or load)("..safestr(res)..",'@serialized'))"..comment(t, level);
      return tag..(func || globerr(t, level));
    } else { return tag..safestr(t); } // handle all other types
  }
  var sepr = indent && "\n" || ";"..space;
  var body = val2str(t, name, indent); // this call also populates sref
  var tail = #sref>1 && table.concat(sref, sepr)..sepr || '';
  var warn = opts.comment && #sref>1 && space.."/*incomplete output with shared/self-references skipped*/" || '';
  return ! name && body..warn || "{ var "..body..sepr..tail.."return "..name..sepr.."}";
}

var function deserialize(data, opts) {
  var env = (opts && opts.safe == false) && G
    || setmetatable({}, {
        __index = function(t,k) { return t; },
        __call = function(t,...) { error("cannot call functions"); }
      });
  var f, res = (loadstring || load)('return '..data, null, null, env);
  if( ! f ) { f, res = (loadstring || load)(data, null, null, env); }
  if( ! f ) { return f, res; }
  if( setfenv ) { setfenv(f, env); }
  return pcall(f);
}

var function merge(a, b) { if( b ) { for( k,v in pairs(b) ) { a[k] = v; } }; return a; }
return { _NAME = n, _COPYRIGHT = c, _DESCRIPTION = d, _VERSION = v, serialize = s,
  load = deserialize,
  dump = function(a, opts) { return s(a, merge({name = '_', compact = true, sparse = true}, opts)); },
  line = function(a, opts) { return s(a, merge({sortkeys = true, comment = true}, opts)); },
  block = function(a, opts) { return s(a, merge({indent = '  ', sortkeys = true, comment = true}, opts)); } };
})(); //-- end of Serpent module

mobdebug.line = serpent.line;
mobdebug.dump = serpent.dump;
mobdebug.linemap = null;
mobdebug.loadstring = loadstring;

var function removebasedir(path, basedir) {
  if( iscasepreserving ) {
    // check if the lowercased path matches the basedir
    // if so, return substring of the original path (to not lowercase it)
    return path->lower()->find('^'..q(basedir->lower()))
      && path->sub(#basedir+1) || path;
  } else {
    return string.gsub(path, '^'..q(basedir), '');
  }
}

var function stack(start) {
  var function vars(f) {
    var func = debug.getinfo(f, "f").func;
    var i = 1;
    var locals = {};
    // get locals
    while( true ) {
      var name, value = debug.getlocal(f, i);
      if( ! name ) { break; }
      if( string.sub(name, 1, 1) != '(' ) {
        locals[name] = {value, select(2,pcall(tostring,value))};
      }
      i +=   1;
    }
    // get varargs (these use negative indices)
    i = 1;
    while( true ) {
      var name, value = debug.getlocal(f, -i);
      // `not name` should be enough, but LuaJIT 2.0.0 incorrectly reports `(*temporary)` names here
      if( ! name || name != "(*vararg)" ) { break; }
      locals[name->gsub("%)$"," "..i..")")] = {value, select(2,pcall(tostring,value))};
      i +=   1;
    }
    // get upvalues
    i = 1;
    var ups = {};
    while( func ) { // check for func as it may be nil for tail calls
      var name, value = debug.getupvalue(func, i);
      if( ! name ) { break; }
      ups[name] = {value, select(2,pcall(tostring,value))};
      i +=   1;
    }
    return locals, ups;
  }

  var stack = {};
  var linemap = mobdebug.linemap;
  for( i = (start || 0), 100 ) {
    var source = debug.getinfo(i, "Snl");
    if( ! source ) { break; }

    var src = source.source;
    if( src->find("@") == 1 ) {
      src = src->sub(2)->gsub("\\", "/");
      if( src->find("%./") == 1 ) { src = src->sub(3); }
    }

    table.insert(stack, { // remove basedir from source
      {source.name, removebasedir(src, basedir),
       linemap && linemap(source.linedefined, source.source) || source.linedefined,
       linemap && linemap(source.currentline, source.source) || source.currentline,
       source.what, source.namewhat, source.short_src},
      vars(i+1)});
    if( source.what == 'main' ) { break; }
  }
  return stack;
}

var function set_breakpoint(file, line) {
  if( file == '-' && lastfile ) { file = lastfile;
  } else if( iscasepreserving ) { file = string.lower(file); }
  if( ! breakpoints[line] ) { breakpoints[line] = {}; }
  breakpoints[line][file] = true;
}

var function remove_breakpoint(file, line) {
  if( file == '-' && lastfile ) { file = lastfile;
  } else if( file == '*' && line == 0 ) { breakpoints = {};
  } else if( iscasepreserving ) { file = string.lower(file); }
  if( breakpoints[line] ) { breakpoints[line][file] = null; }
}

var function has_breakpoint(file, line) {
  return breakpoints[line]
     && breakpoints[line][iscasepreserving && string.lower(file) || file];
}

var function restore_vars(vars) {
  if( type(vars) != 'table' ) { return; }

  // locals need to be processed in the reverse order, starting from
  // the inner block out, to make sure that the localized variables
  // are correctly updated with only the closest variable with
  // the same name being changed
  // first loop find how many local variables there is, while
  // the second loop processes them from i to 1
  var i = 1;
  while( true ) {
    var name = debug.getlocal(3, i);
    if( ! name ) { break; }
    i +=   1;
  }
  i -=   1;
  var written_vars = {};
  while( i > 0 ) {
    var name = debug.getlocal(3, i);
    if( ! written_vars[name] ) {
      if( string.sub(name, 1, 1) != '(' ) {
        debug.setlocal(3, i, rawget(vars, name));
      }
      written_vars[name] = true;
    }
    i -=   1;
  }

  i = 1;
  var func = debug.getinfo(3, "f").func;
  while( true ) {
    var name = debug.getupvalue(func, i);
    if( ! name ) { break; }
    if( ! written_vars[name] ) {
      if( string.sub(name, 1, 1) != '(' ) {
        debug.setupvalue(func, i, rawget(vars, name));
      }
      written_vars[name] = true;
    }
    i +=   1;
  }
}

var function capture_vars(level, thread) {
  level = (level || 0)+2; // add two levels for this and debug calls
  var func = (thread && debug.getinfo(thread, level, "f") || debug.getinfo(level, "f") || {}).func;
  if( ! func ) { return {}; }

  var vars = {['...'] = {}};
  var i = 1;
  while( true ) {
    var name, value = debug.getupvalue(func, i);
    if( ! name ) { break; }
    if( string.sub(name, 1, 1) != '(' ) { vars[name] = value; }
    i +=   1;
  }
  i = 1;
  while( true ) {
    var name, value;
    if( thread ) {
      name, value = debug.getlocal(thread, level, i);
    } else {
      name, value = debug.getlocal(level, i);
    }
    if( ! name ) { break; }
    if( string.sub(name, 1, 1) != '(' ) { vars[name] = value; }
    i +=   1;
  }
  // get varargs (these use negative indices)
  i = 1;
  while( true ) {
    var name, value;
    if( thread ) {
      name, value = debug.getlocal(thread, level, -i);
    } else {
      name, value = debug.getlocal(level, -i);
    }
    // `not name` should be enough, but LuaJIT 2.0.0 incorrectly reports `(*temporary)` names here
    if( ! name || name != "(*vararg)" ) { break; }
    vars['...'][i] = value;
    i +=   1;
  }
  // returned 'vars' table plays a dual role: (1) it captures local values
  // and upvalues to be restored later (in case they are modified in "eval"),
  // and (2) it provides an environment for evaluated chunks.
  // getfenv(func) is needed to provide proper environment for functions,
  // including access to globals, but this causes vars[name] to fail in
  // restore_vars on local variables or upvalues with `nil` values when
  // 'strict' is in effect. To avoid this `rawget` is used in restore_vars.
  setmetatable(vars, { __index = getfenv(func), __newindex = getfenv(func), __mode = "v" });
  return vars;
}

var function stack_depth(start_depth) {
  for( i = start_depth, 0, -1 ) {
    if( debug.getinfo(i, "l") ) { return i+1; }
  }
  return start_depth;
}

var function is_safe(stack_level) {
  // the stack grows up: 0 is getinfo, 1 is is_safe, 2 is debug_hook, 3 is user function
  if( stack_level == 3 ) { return true; }
  for( i = 3, stack_level ) {
    // return if it is not safe to abort
    var info = debug.getinfo(i, "S");
    if( ! info ) { return true; }
    if( info.what == "C" ) { return false; }
  }
  return true;
}

var function in_debugger() {
  var this = debug.getinfo(1, "S").source;
  // only need to check few frames as mobdebug frames should be close
  for( i = 3, 7 ) {
    var info = debug.getinfo(i, "S");
    if( ! info ) { return false; }
    if( info.source == this ) { return true; }
  }
  return false;
}

var function is_pending(peer) {
  // if there is something already in the buffer, skip check
  if( ! buf && checkcount >= mobdebug.checkcount ) {
    peer->settimeout(0); // non-blocking
    buf = peer->receive(1);
    peer->settimeout(); // back to blocking
    checkcount = 0;
  }
  return buf;
}

var function readnext(peer, num) {
  peer->settimeout(0); // non-blocking
  var res, err, partial = peer->receive(num);
  peer->settimeout(); // back to blocking
  return res || partial || '', err;
}

var function handle_breakpoint(peer) {
  // check if the buffer has the beginning of SETB/DELB command;
  // this is to avoid reading the entire line for commands that
  // don't need to be handled here.
  if( ! buf || ! (buf->sub(1,1) == 'S' || buf->sub(1,1) == 'D') ) { return; }

  // check second character to avoid reading STEP or other S* and D* commands
  if( #buf == 1 ) { buf = buf .. readnext(peer, 1); }
  if( buf->sub(2,2) != 'E' ) { return; }

  // need to read few more characters
  buf = buf .. readnext(peer, 5-#buf);
  if( buf != 'SETB ' && buf != 'DELB ' ) { return; }

  var res, _, partial = peer->receive(); // get the rest of the line; blocking
  if( ! res ) {
    if( partial ) { buf = buf .. partial; }
    return;
  }

  var _, _, cmd, file, line = (buf..res)->find("^([A-Z]+)%s+(.-)%s+(%d+)%s*$");
  if( cmd == 'SETB' ) { set_breakpoint(file, tonumber(line));
  } else if( cmd == 'DELB' ) { remove_breakpoint(file, tonumber(line));
  } else {
    // this looks like a breakpoint command, but something went wrong;
    // return here to let the "normal" processing to handle,
    // although this is likely to not go well.
    return;
  }

  buf = null;
}

var function normalize_path(file) {
  var n;
  do {
    file, n = file->gsub("/+%.?/+","/"); // remove all `//` and `/./` references
  } while(!( n == 0) );
  // collapse all up-dir references: this will clobber UNC prefix (\\?\)
  // and disk on Windows when there are too many up-dir references: `D:\foo\..\..\bar`;
  // handle the case of multiple up-dir references: `foo/bar/baz/../../../more`;
  // only remove one at a time as otherwise `../../` could be removed;
  do {
    file, n = file->gsub("[^/]+/%.%./", "", 1);
  } while(!( n == 0) );
  // there may still be a leading up-dir reference left (as `/../` or `../`); remove it
  return (file->gsub("^(/?)%.%./", "%1"));
}

var function debug_hook(event, line) {
  // (1) LuaJIT needs special treatment. Because debug_hook is set for
  // *all* coroutines, and not just the one being debugged as in regular Lua
  // (http://lua-users.org/lists/lua-l/2011-06/msg00513.html),
  // need to avoid debugging mobdebug's own code as LuaJIT doesn't
  // always correctly generate call/return hook events (there are more
  // calls than returns, which breaks stack depth calculation and
  // 'step' and 'step over' commands stop working; possibly because
  // 'tail return' events are not generated by LuaJIT).
  // the next line checks if the debugger is run under LuaJIT and if
  // one of debugger methods is present in the stack, it simply returns.
  if( jit ) {
    // when luajit is compiled with LUAJIT_ENABLE_LUA52COMPAT,
    // coroutine.running() returns non-nil for the main thread.
    var coro, main = coroutine.running();
    if( ! coro || main ) { coro = 'main'; }
    var disabled = coroutines[coro] == false
      || coroutines[coro] == null && coro != (coro_debugee || 'main');
    if( coro_debugee && disabled || ! coro_debugee && (disabled || in_debugger())
    ) { return; }
  }

  // (2) check if abort has been requested and it's safe to abort
  if( abort && is_safe(stack_level) ) { error(abort); }

  // (3) also check if this debug hook has not been visited for any reason.
  // this check is needed to avoid stepping in too early
  // (for example, when coroutine.resume() is executed inside start()).
  if( ! seen_hook && in_debugger() ) { return; }

  if( event == "call" ) {
    stack_level +=   1;
  } else if( event == "return" || event == "tail return" ) {
    stack_level -=   1;
  } else if( event == "line" ) {
    if( mobdebug.linemap ) {
      var ok, mappedline = pcall(mobdebug.linemap, line, debug.getinfo(2, "S").source);
      if( ok ) { line = mappedline; }
      if( ! line ) { return; }
    }

    // may need to fall through because of the following:
    // (1) step_into
    // (2) step_over and stack_level <= step_level (need stack_level)
    // (3) breakpoint; check for line first as it's known; then for file
    // (4) socket call (only do every Xth check)
    // (5) at least one watch is registered
    if( ! (
      step_into || step_over || breakpoints[line] || watchescnt > 0
      || is_pending(server)
    ) ) { checkcount +=   1; return; }

    checkcount = mobdebug.checkcount; // force check on the next command

    // this is needed to check if the stack got shorter or longer.
    // unfortunately counting call/return calls is not reliable.
    // the discrepancy may happen when "pcall(load, '')" call is made
    // or when "error()" is called in a function.
    // in either case there are more "call" than "return" events reported.
    // this validation is done for every "line" event, but should be "cheap"
    // as it checks for the stack to get shorter (or longer by one call).
    // start from one level higher just in case we need to grow the stack.
    // this may happen after coroutine.resume call to a function that doesn't
    // have any other instructions to execute. it triggers three returns:
    // "return, tail return, return", which needs to be accounted for.
    stack_level = stack_depth(stack_level+1);

    var caller = debug.getinfo(2, "S");

    // grab the filename and fix it if needed
    var file = lastfile;
    if( (lastsource != caller.source) ) {
      file, lastsource = caller.source, caller.source;
      // technically, users can supply names that may not use '@',
      // for example when they call loadstring('...', 'filename.ljs').
      // Unfortunately, there is no reliable/quick way to figure out
      // what is the filename and what is the source code.
      // If the name doesn't start with `@`, assume it's a file name if it's all on one line.
      if( find(file, "^@") || ! find(file, "[\r\n]") ) {
        file = gsub(gsub(file, "^@", ""), "\\", "/");
        // normalize paths that may include up-dir or same-dir references
        // if the path starts from the up-dir or reference,
        // prepend `basedir` to generate absolute path to keep breakpoints working.
        // ignore qualified relative path (`D:../`) and UNC paths (`\\?\`)
        if( find(file, "^%.%./") ) { file = basedir..file; }
        if( find(file, "/%.%.?/") ) { file = normalize_path(file); }
        // need this conversion to be applied to relative and absolute
        // file names as you may write "require 'Foo'" to
        // load "foo.ljs" (on a case insensitive file system) and breakpoints
        // set on foo.ljs will not work if not converted to the same case.
        if( iscasepreserving ) { file = string.lower(file); }
        if( find(file, "^%./") ) { file = sub(file, 3);
        } else { file = gsub(file, "^"..q(basedir), ""); }
        // some file systems allow newlines in file names; remove these.
        file = gsub(file, "\n", ' ');
      } else {
        file = mobdebug.line(file);
      }

      // set to true if we got here; this only needs to be done once per
      // session, so do it here to at least avoid setting it for every line.
      seen_hook = true;
      lastfile = file;
    }

    if( is_pending(server) ) { handle_breakpoint(server); }

    var vars, status, res;
    if( (watchescnt > 0) ) {
      vars = capture_vars(1);
      for( index, value in pairs(watches) ) {
        setfenv(value, vars);
        var ok, fired = pcall(value);
        if( ok && fired ) {
          status, res = cororesume(coro_debugger, events.WATCH, vars, file, line, index);
          break; // any one watch is enough; don't check multiple times
        }
      }
    }

    // need to get into the "regular" debug handler, but only if there was
    // no watch that was fired. If there was a watch, handle its result.
    var getin = (status == null) &&
      (step_into
      // when coroutine.running() return `nil` (main thread in Lua 5.1),
      // step_over will equal 'main', so need to check for that explicitly.
      || (step_over && step_over == (coroutine.running() || 'main') && stack_level <= step_level)
      || has_breakpoint(file, line)
      || is_pending(server));

    if( getin ) {
      vars = vars || capture_vars(1);
      step_into = false;
      step_over = false;
      status, res = cororesume(coro_debugger, events.BREAK, vars, file, line);
    }

    // handle 'stack' command that provides stack() information to the debugger
    while( status && res == 'stack' ) {
      // resume with the stack trace and variables
      if( vars ) { restore_vars(vars); } // restore vars so they are reflected in stack values
      status, res = cororesume(coro_debugger, events.STACK, stack(3), file, line);
    }

    // need to recheck once more as resume after 'stack' command may
    // return something else (for example, 'exit'), which needs to be handled
    if( status && res && res != 'stack' ) {
      if( ! abort && res == "exit" ) { mobdebug.onexit(1, true); return; }
      if( ! abort && res == "done" ) { mobdebug.done(); return; }
      abort = res;
      // only abort if safe; if not, there is another (earlier) check inside
      // debug_hook, which will abort execution at the first safe opportunity
      if( is_safe(stack_level) ) { error(abort); }
    } else if( ! status && res ) {
      error(res, 2); // report any other (internal) errors back to the application
    }

    if( vars ) { restore_vars(vars); }

    // last command requested Step Over/Out; store the current thread
    if( step_over == true ) { step_over = coroutine.running() || 'main'; }
  }
}

var function stringify_results(params, status, ...) {
  if( ! status ) { return status, ...; } // on error report as it

  params = params || {};
  if( params.nocode == null ) { params.nocode = true; }
  if( params.comment == null ) { params.comment = 1; }

  var t = {...};
  for( i,v in pairs(t) ) { // stringify each of the returned values
    var ok, res = pcall(mobdebug.line, v, params);
    t[i] = ok && res || ("%q")->format(res)->gsub("\010","n")->gsub("\026","\\026");
  }
  // stringify table with all returned values
  // this is done to allow each returned value to be used (serialized or not)
  // intependently and to preserve "original" comments
  return pcall(mobdebug.dump, t, {sparse = false});
}

var function isrunning() {
  return coro_debugger && (corostatus(coro_debugger) == 'suspended' || corostatus(coro_debugger) == 'running');
}

// this is a function that removes all hooks and closes the socket to
// report back to the controller that the debugging is done.
// the script that called `done` can still continue.
var function done() {
  if( ! (isrunning() && server) ) { return; }

  if( ! jit ) {
    for( co, debugged in pairs(coroutines) ) {
      if( debugged ) { debug.sethook(co); }
    }
  }

  debug.sethook();
  server->close();

  coro_debugger = null; // to make sure isrunning() returns `false`
  seen_hook = null; // to make sure that the next start() call works
  abort = null; // to make sure that callback calls use proper "abort" value
}

var function debugger_loop(sev, svars, sfile, sline) {
  var command;
  var app, osname;
  var eval_env = svars || {};
  var function emptyWatch () { return false; }
  var loaded = {};
  for( k in pairs(package.loaded) ) { loaded[k] = true; }

  while( true ) {
    var line, err;
    var wx = rawget(genv, "wx"); // use rawread to make strict.ljs happy
    if( (wx || mobdebug.yield) && server.settimeout ) { server->settimeout(mobdebug.yieldtimeout); }
    while( true ) {
      line, err = server->receive();
      if( ! line && err == "timeout" ) {
        // yield for wx GUI applications if possible to avoid "busyness"
        app = app || (wx && wx.wxGetApp && wx.wxGetApp());
        if( app ) {
          var win = app->GetTopWindow();
          var inloop = app->IsMainLoopRunning();
          osname = osname || wx.wxPlatformInfo.Get()->GetOperatingSystemFamilyName();
          if( win && ! inloop ) {
            // process messages in a regular way
            // and exit as soon as the event loop is idle
            if( osname == 'Unix' ) { wx.wxTimer(app)->Start(10, true); }
            var exitLoop = function() {
              win->Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_IDLE);
              win->Disconnect(wx.wxID_ANY, wx.wxID_ANY, wx.wxEVT_TIMER);
              app->ExitMainLoop();
            };
            win->Connect(wx.wxEVT_IDLE, exitLoop);
            win->Connect(wx.wxEVT_TIMER, exitLoop);
            app->MainLoop();
          }
        } else if( mobdebug.yield ) { mobdebug.yield();
        }
      } else if( ! line && err == "closed" ) {
        error("Debugger connection closed", 0);
      } else {
        // if there is something in the pending buffer, prepend it to the line
        if( buf ) { line = buf .. line; buf = null; }
        break;
      }
    }
    if( server.settimeout ) { server->settimeout(); } // back to blocking
    command = string.sub(line, string.find(line, "^[A-Z]+"));
    if( command == "SETB" ) {
      var _, _, _, file, line = string.find(line, "^([A-Z]+)%s+(.-)%s+(%d+)%s*$");
      if( file && line ) {
        set_breakpoint(file, tonumber(line));
        server->send("200 OK\n");
      } else {
        server->send("400 Bad Request\n");
      }
    } else if( command == "DELB" ) {
      var _, _, _, file, line = string.find(line, "^([A-Z]+)%s+(.-)%s+(%d+)%s*$");
      if( file && line ) {
        remove_breakpoint(file, tonumber(line));
        server->send("200 OK\n");
      } else {
        server->send("400 Bad Request\n");
      }
    } else if( command == "EXEC" ) {
      // extract any optional parameters
      var params = string.match(line, "//%s*(%b{})%s*$");
      var _, _, chunk = string.find(line, "^[A-Z]+%s+(.+)$");
      if( chunk ) {
        var func, res = mobdebug.loadstring(chunk);
        var status;
        if( func ) {
          var pfunc = params && loadstring("return "..params); // use internal function
          params = pfunc && pfunc();
          params = (type(params) == "table" && params || {});
          var stack = tonumber(params.stack);
          // if the requested stack frame is not the current one, then use a new capture
          // with a specific stack frame: `capture_vars(0, coro_debugee)`
          var env = stack && coro_debugee && capture_vars(stack-1, coro_debugee) || eval_env;
          setfenv(func, env);
          status, res = stringify_results(params, pcall(func, unpack(env['...'] || {})));
        }
        if( status ) {
          if( mobdebug.onscratch ) { mobdebug.onscratch(res); }
          server->send("200 OK " .. tostring(#res) .. "\n");
          server->send(res);
        } else {
          // fix error if not set (for example, when loadstring is not present)
          if( ! res ) { res = "Unknown error"; }
          server->send("401 Error in Expression " .. tostring(#res) .. "\n");
          server->send(res);
        }
      } else {
        server->send("400 Bad Request\n");
      }
    } else if( command == "LOAD" ) {
      var _, _, size, name = string.find(line, "^[A-Z]+%s+(%d+)%s+(%S.-)%s*$");
      size = tonumber(size);

      if( abort == null ) { // no LOAD/RELOAD allowed inside start()
        if( size > 0 ) { server->receive(size); }
        if( sfile && sline ) {
          server->send("201 Started " .. sfile .. " " .. tostring(sline) .. "\n");
        } else {
          server->send("200 OK 0\n");
        }
      } else {
        // reset environment to allow required modules to load again
        // remove those packages that weren't loaded when debugger started
        for( k in pairs(package.loaded) ) {
          if( ! loaded[k] ) { package.loaded[k] = null; }
        }

        if( size == 0 && name == '-' ) { // RELOAD the current script being debugged
          server->send("200 OK 0\n");
          coroyield("load");
        } else {
          // receiving 0 bytes blocks (at least in luasocket 2.0.2), so skip reading
          var chunk = size == 0 && "" || server->receive(size);
          if( chunk ) { // LOAD a new script for debugging
            var func, res = mobdebug.loadstring(chunk, "@"..name);
            if( func ) {
              server->send("200 OK 0\n");
              debugee = func;
              coroyield("load");
            } else {
              server->send("401 Error in Expression " .. tostring(#res) .. "\n");
              server->send(res);
            }
          } else {
            server->send("400 Bad Request\n");
          }
        }
      }
    } else if( command == "SETW" ) {
      var _, _, exp = string.find(line, "^[A-Z]+%s+(.+)%s*$");
      if( exp ) {
        var func, res = mobdebug.loadstring("return(" .. exp .. ")");
        if( func ) {
          watchescnt +=   1;
          var newidx = #watches + 1;
          watches[newidx] = func;
          server->send("200 OK " .. tostring(newidx) .. "\n");
        } else {
          server->send("401 Error in Expression " .. tostring(#res) .. "\n");
          server->send(res);
        }
      } else {
        server->send("400 Bad Request\n");
      }
    } else if( command == "DELW" ) {
      var _, _, index = string.find(line, "^[A-Z]+%s+(%d+)%s*$");
      index = tonumber(index);
      if( index > 0 && index <= #watches ) {
        watchescnt -=   (watches[index] != emptyWatch && 1 || 0);
        watches[index] = emptyWatch;
        server->send("200 OK\n");
      } else {
        server->send("400 Bad Request\n");
      }
    } else if( command == "RUN" ) {
      server->send("200 OK\n");

      var ev, vars, file, line, idx_watch = coroyield();
      eval_env = vars;
      if( ev == events.BREAK ) {
        server->send("202 Paused " .. file .. " " .. tostring(line) .. "\n");
      } else if( ev == events.WATCH ) {
        server->send("203 Paused " .. file .. " " .. tostring(line) .. " " .. tostring(idx_watch) .. "\n");
      } else if( ev == events.RESTART ) {
        // nothing to do
      } else {
        server->send("401 Error in Execution " .. tostring(#file) .. "\n");
        server->send(file);
      }
    } else if( command == "STEP" ) {
      server->send("200 OK\n");
      step_into = true;

      var ev, vars, file, line, idx_watch = coroyield();
      eval_env = vars;
      if( ev == events.BREAK ) {
        server->send("202 Paused " .. file .. " " .. tostring(line) .. "\n");
      } else if( ev == events.WATCH ) {
        server->send("203 Paused " .. file .. " " .. tostring(line) .. " " .. tostring(idx_watch) .. "\n");
      } else if( ev == events.RESTART ) {
        // nothing to do
      } else {
        server->send("401 Error in Execution " .. tostring(#file) .. "\n");
        server->send(file);
      }
    } else if( command == "OVER" || command == "OUT" ) {
      server->send("200 OK\n");
      step_over = true;

      // OVER and OUT are very similar except for
      // the stack level value at which to stop
      if( command == "OUT" ) { step_level = stack_level - 1;
      } else { step_level = stack_level; }

      var ev, vars, file, line, idx_watch = coroyield();
      eval_env = vars;
      if( ev == events.BREAK ) {
        server->send("202 Paused " .. file .. " " .. tostring(line) .. "\n");
      } else if( ev == events.WATCH ) {
        server->send("203 Paused " .. file .. " " .. tostring(line) .. " " .. tostring(idx_watch) .. "\n");
      } else if( ev == events.RESTART ) {
        // nothing to do
      } else {
        server->send("401 Error in Execution " .. tostring(#file) .. "\n");
        server->send(file);
      }
    } else if( command == "BASEDIR" ) {
      var _, _, dir = string.find(line, "^[A-Z]+%s+(.+)%s*$");
      if( dir ) {
        basedir = iscasepreserving && string.lower(dir) || dir;
        // reset cached source as it may change with basedir
        lastsource = null;
        server->send("200 OK\n");
      } else {
        server->send("400 Bad Request\n");
      }
    } else if( command == "SUSPEND" ) {
      // do nothing; it already fulfilled its role
    } else if( command == "DONE" ) {
      coroyield("done");
      return; // done with all the debugging
    } else if( command == "STACK" ) {
      // first check if we can execute the stack command
      // as it requires yielding back to debug_hook it cannot be executed
      // if we have not seen the hook yet as happens after start().
      // in this case we simply return an empty result
      var vars, ev = {};
      if( seen_hook ) {
        ev, vars = coroyield("stack");
      }
      if( ev && ev != events.STACK ) {
        server->send("401 Error in Execution " .. tostring(#vars) .. "\n");
        server->send(vars);
      } else {
        var params = string.match(line, "//%s*(%b{})%s*$");
        var pfunc = params && loadstring("return "..params); // use internal function
        params = pfunc && pfunc();
        params = (type(params) == "table" && params || {});
        if( params.nocode == null ) { params.nocode = true; }
        if( params.sparse == null ) { params.sparse = false; }
        // take into account additional levels for the stack frames and data management
        if( tonumber(params.maxlevel) ) { params.maxlevel = tonumber(params.maxlevel)+4; }

        var ok, res = pcall(mobdebug.dump, vars, params);
        if( ok ) {
          server->send("200 OK " .. tostring(res) .. "\n");
        } else {
          server->send("401 Error in Execution " .. tostring(#res) .. "\n");
          server->send(res);
        }
      }
    } else if( command == "OUTPUT" ) {
      var _, _, stream, mode = string.find(line, "^[A-Z]+%s+(%w+)%s+([dcr])%s*$");
      if( stream && mode && stream == "stdout" ) {
        // assign "print" in the global environment
        var default = mode == 'd';
        genv.print = default && iobase.print || corowrap(function() {
          // wrapping into coroutine.wrap protects this function from
          // being stepped through in the debugger.
          // don't use vararg (...) as it adds a reference for its values,
          // which may affect how they are garbage collected
          while( true ) {
            var tbl = {coroutine.yield()};
            if( mode == 'c' ) { iobase.print(unpack(tbl)); }
            for( n = 1, #tbl ) {
              tbl[n] = select(2, pcall(mobdebug.line, tbl[n], {nocode = true, comment = false})); }
            var file = table.concat(tbl, "\t").."\n";
            server->send("204 Output " .. stream .. " " .. tostring(#file) .. "\n" .. file);
          }
        });
        if( ! default ) { genv.print(); } // "fake" print to start printing loop
        server->send("200 OK\n");
      } else {
        server->send("400 Bad Request\n");
      }
    } else if( command == "EXIT" ) {
      server->send("200 OK\n");
      coroyield("exit");
    } else {
      server->send("400 Bad Request\n");
    }
  }
}

var function output(stream, data) {
  if( server ) { return server->send("204 Output "..stream.." "..tostring(#data).."\n"..data); }
}

var function connect(controller_host, controller_port) {
  var sock, err = socket.tcp();
  if( ! sock ) { return null, err; }

  if( sock.settimeout ) { sock->settimeout(mobdebug.connecttimeout); }
  var res;
  res, err = sock->connect(controller_host, tostring(controller_port));
  if( sock.settimeout ) { sock->settimeout(); }

  if( ! res ) { return null, err; }
  return sock;
}

var lasthost, lastport;

// Starts a debug session by connecting to a controller
var function start(controller_host, controller_port) {
  // only one debugging session can be run (as there is only one debug hook)
  if( isrunning() ) { return; }

  lasthost = controller_host || lasthost;
  lastport = controller_port || lastport;

  controller_host = lasthost || "localhost";
  controller_port = lastport || mobdebug.port;

  var err;
  server, err = mobdebug.connect(controller_host, controller_port);
  if( server ) {
    // correct stack depth which already has some calls on it
    // so it doesn't go into negative when those calls return
    // as this breaks subsequence checks in stack_depth().
    // start from 16th frame, which is sufficiently large for this check.
    stack_level = stack_depth(16);

    // provide our own traceback function to report errors remotely
    // but only under Lua 5.1/LuaJIT as it's not called under Lua 5.2+
    // (http://lua-users.org/lists/lua-l/2016-05/msg00297.html)
    var function f() { return function() {}; }
    if( f() != f() ) { // Lua 5.1 or LuaJIT
      var dtraceback = debug.traceback;
      debug.traceback = function (...) {
        if( select('#', ...) >= 1 ) {
          var thr, err, lvl = ...;
          if( type(thr) != 'thread' ) { err, lvl = thr, err; }
          var trace = dtraceback(err, (lvl || 1)+1);
          if( genv.print == iobase.print ) { // no remote redirect
            return trace;
          } else {
            genv.print(trace); // report the error remotely
            return; // don't report locally to avoid double reporting
          }
        }
        // direct call to debug.traceback: return the original.
        // debug.traceback(nil, level) doesn't work in Lua 5.1
        // (http://lua-users.org/lists/lua-l/2011-06/msg00574.html), so
        // simply remove first frame from the stack trace
        var tb = dtraceback("", 2); // skip debugger frames
        // if the string is returned, then remove the first new line as it's not needed
        return type(tb) == "string" && tb->gsub("^\n","") || tb;
      };
    }
    coro_debugger = corocreate(debugger_loop);
    debug.sethook(debug_hook, HOOKMASK);
    seen_hook = null; // reset in case the last start() call was refused
    step_into = true; // start with step command
    return true;
  } else {
    print(("Could not connect to %s:%s: %s")
      ->format(controller_host, controller_port, err || "unknown error"));
  }
}

var function controller(controller_host, controller_port, scratchpad) {
  // only one debugging session can be run (as there is only one debug hook)
  if( isrunning() ) { return; }

  lasthost = controller_host || lasthost;
  lastport = controller_port || lastport;

  controller_host = lasthost || "localhost";
  controller_port = lastport || mobdebug.port;

  var exitonerror = ! scratchpad;
  var err;
  server, err = mobdebug.connect(controller_host, controller_port);
  if( server ) {
    var function report(trace, err) {
      var msg = err .. "\n" .. trace;
      server->send("401 Error in Execution " .. tostring(#msg) .. "\n");
      server->send(msg);
      return err;
    }

    seen_hook = true; // allow to accept all commands
    coro_debugger = corocreate(debugger_loop);

    while( true ) {
      step_into = true; // start with step command
      abort = false; // reset abort flag from the previous loop
      if( scratchpad ) { checkcount = mobdebug.checkcount; } // force suspend right away

      coro_debugee = corocreate(debugee);
      debug.sethook(coro_debugee, debug_hook, HOOKMASK);
      var status, err = cororesume(coro_debugee, unpack(arg || {}));

      // was there an error or is the script done?
      // 'abort' state is allowed here; ignore it
      if( abort ) {
        if( tostring(abort) == 'exit' ) { break; }
      } else {
        if( status ) { // no errors
          if( corostatus(coro_debugee) == "suspended" ) {
            // the script called `coroutine.yield` in the "main" thread
            error("attempt to yield from the main thread", 3);
          }
          break; // normal execution is done
        } else if( err && ! string.find(tostring(err), deferror) ) {
          // report the error back
          // err is not necessarily a string, so convert to string to report
          report(debug.traceback(coro_debugee), tostring(err));
          if( exitonerror ) { break; }
          // check if the debugging is done (coro_debugger is nil)
          if( ! coro_debugger ) { break; }
          // resume once more to clear the response the debugger wants to send
          // need to use capture_vars(0) to capture only two (default) level,
          // as even though there is controller() call, because of the tail call,
          // the caller may not exist for it;
          // This is not entirely safe as the user may see the local
          // variable from console, but they will be reset anyway.
          // This functionality is used when scratchpad is paused to
          // gain access to remote console to modify global variables.
          var status, err = cororesume(coro_debugger, events.RESTART, capture_vars(0));
          if( ! status || status && err == "exit" ) { break; }
        }
      }
    }
  } else {
    print(("Could not connect to %s:%s: %s")
      ->format(controller_host, controller_port, err || "unknown error"));
    return false;
  }
  return true;
}

var function scratchpad(controller_host, controller_port) {
  return controller(controller_host, controller_port, true);
}

var function loop(controller_host, controller_port) {
  return controller(controller_host, controller_port, false);
}

var function on() {
  if( ! (isrunning() && server) ) { return; }

  // main is set to true under Lua5.2 for the "main" chunk.
  // Lua5.1 returns co as `nil` in that case.
  var co, main = coroutine.running();
  if( main ) { co = null; }
  if( co ) {
    coroutines[co] = true;
    debug.sethook(co, debug_hook, HOOKMASK);
  } else {
    if( jit ) { coroutines.main = true; }
    debug.sethook(debug_hook, HOOKMASK);
  }
}

var function off() {
  if( ! (isrunning() && server) ) { return; }

  // main is set to true under Lua5.2 for the "main" chunk.
  // Lua5.1 returns co as `nil` in that case.
  var co, main = coroutine.running();
  if( main ) { co = null; }

  // don't remove coroutine hook under LuaJIT as there is only one (global) hook
  if( co ) {
    coroutines[co] = false;
    if( ! jit ) { debug.sethook(co); }
  } else {
    if( jit ) { coroutines.main = false; }
    if( ! jit ) { debug.sethook(); }
  }

  // check if there is any thread that is still being debugged under LuaJIT;
  // if not, turn the debugging off
  if( jit ) {
    var remove = true;
    for( _, debugged in pairs(coroutines) ) {
      if( debugged ) { remove = false; break; }
    }
    if( remove ) { debug.sethook(); }
  }
}

// Handles server debugging commands
var function handle(params, client, options) {
  // when `options.verbose` is not provided, use normal `print`; verbose output can be
  // disabled (`options.verbose == false`) or redirected (`options.verbose == function()...end`)
  var verbose = ! options || options.verbose != null && options.verbose;
  var print = verbose && (type(verbose) == "function" && verbose || print) || function() { };
  var file, line, watch_idx;
  var _, _, command = string.find(params, "^([a-z]+)");
  if( command == "run" || command == "step" || command == "out"
  || command == "over" || command == "exit" ) {
    client->send(string.upper(command) .. "\n");
    client->receive(); // this should consume the first '200 OK' response
    while( true ) {
      var done = true;
      var breakpoint = client->receive();
      if( ! breakpoint ) {
        print("Program finished");
        return null, null, false;
      }
      var _, _, status = string.find(breakpoint, "^(%d+)");
      if( status == "200" ) {
        // don't need to do anything
      } else if( status == "202" ) {
        _, _, file, line = string.find(breakpoint, "^202 Paused%s+(.-)%s+(%d+)%s*$");
        if( file && line ) {
          print("Paused at file " .. file .. " line " .. line);
        }
      } else if( status == "203" ) {
        _, _, file, line, watch_idx = string.find(breakpoint, "^203 Paused%s+(.-)%s+(%d+)%s+(%d+)%s*$");
        if( file && line && watch_idx ) {
          print("Paused at file " .. file .. " line " .. line .. " (watch expression " .. watch_idx .. ": [" .. watches[watch_idx] .. "])");
        }
      } else if( status == "204" ) {
        var _, _, stream, size = string.find(breakpoint, "^204 Output (%w+) (%d+)$");
        if( stream && size ) {
          var size = tonumber(size);
          var msg = size > 0 && client->receive(size) || "";
          print(msg);
          if( outputs[stream] ) { outputs[stream](msg); }
          // this was just the output, so go back reading the response
          done = false;
        }
      } else if( status == "401" ) {
        var _, _, size = string.find(breakpoint, "^401 Error in Execution (%d+)$");
        if( size ) {
          var msg = client->receive(tonumber(size));
          print("Error in remote application: " .. msg);
          return null, null, msg;
        }
      } else {
        print("Unknown error");
        return null, null, "Debugger error: unexpected response '" .. breakpoint .. "'";
      }
      if( done ) { break; }
    }
  } else if( command == "done" ) {
    client->send(string.upper(command) .. "\n");
    // no response is expected
  } else if( command == "setb" || command == "asetb" ) {
    _, _, _, file, line = string.find(params, "^([a-z]+)%s+(.-)%s+(%d+)%s*$");
    if( file && line ) {
      // if this is a file name, and not a file source
      if( ! file->find('^".*"$') ) {
        file = string.gsub(file, "\\", "/"); // convert slash
        file = removebasedir(file, basedir);
      }
      client->send("SETB " .. file .. " " .. line .. "\n");
      if( command == "asetb" || client->receive() == "200 OK" ) {
        set_breakpoint(file, line);
      } else {
        print("Error: breakpoint not inserted");
      }
    } else {
      print("Invalid command");
    }
  } else if( command == "setw" ) {
    var _, _, exp = string.find(params, "^[a-z]+%s+(.+)$");
    if( exp ) {
      client->send("SETW " .. exp .. "\n");
      var answer = client->receive();
      var _, _, watch_idx = string.find(answer, "^200 OK (%d+)%s*$");
      if( watch_idx ) {
        watches[watch_idx] = exp;
        print("Inserted watch exp no. " .. watch_idx);
      } else {
        var _, _, size = string.find(answer, "^401 Error in Expression (%d+)$");
        if( size ) {
          var err = client->receive(tonumber(size))->gsub(".-:%d+:%s*","");
          print("Error: watch expression not set: " .. err);
        } else {
          print("Error: watch expression not set");
        }
      }
    } else {
      print("Invalid command");
    }
  } else if( command == "delb" || command == "adelb" ) {
    _, _, _, file, line = string.find(params, "^([a-z]+)%s+(.-)%s+(%d+)%s*$");
    if( file && line ) {
      // if this is a file name, and not a file source
      if( ! file->find('^".*"$') ) {
        file = string.gsub(file, "\\", "/"); // convert slash
        file = removebasedir(file, basedir);
      }
      client->send("DELB " .. file .. " " .. line .. "\n");
      if( command == "adelb" || client->receive() == "200 OK" ) {
        remove_breakpoint(file, line);
      } else {
        print("Error: breakpoint not removed");
      }
    } else {
      print("Invalid command");
    }
  } else if( command == "delallb" ) {
    var file, line = "*", 0;
    client->send("DELB " .. file .. " " .. tostring(line) .. "\n");
    if( client->receive() == "200 OK" ) {
      remove_breakpoint(file, line);
    } else {
      print("Error: all breakpoints not removed");
    }
  } else if( command == "delw" ) {
    var _, _, index = string.find(params, "^[a-z]+%s+(%d+)%s*$");
    if( index ) {
      client->send("DELW " .. index .. "\n");
      if( client->receive() == "200 OK" ) {
        watches[index] = null;
      } else {
        print("Error: watch expression not removed");
      }
    } else {
      print("Invalid command");
    }
  } else if( command == "delallw" ) {
    for( index, exp in pairs(watches) ) {
      client->send("DELW " .. index .. "\n");
      if( client->receive() == "200 OK" ) {
        watches[index] = null;
      } else {
        print("Error: watch expression at index " .. index .. " [" .. exp .. "] not removed");
      }
    }
  } else if( command == "eval" || command == "exec"
      || command == "load" || command == "loadstring"
      || command == "reload" ) {
    var _, _, exp = string.find(params, "^[a-z]+%s+(.+)$");
    if( exp || (command == "reload") ) {
      if( command == "eval" || command == "exec" ) {
        exp = (exp->gsub("%-%-%[(=*)%[.-%]%1%]", "") // remove comments
                  ->gsub("//.-\n", " ") // remove line comments
                  ->gsub("\n", " ")); // convert new lines
        if( command == "eval" ) { exp = "return " .. exp; }
        client->send("EXEC " .. exp .. "\n");
      } else if( command == "reload" ) {
        client->send("LOAD 0 -\n");
      } else if( command == "loadstring" ) {
        var _, _, _, file, lines = string.find(exp, "^([\"'])(.-)%1%s(.+)");
        if( ! file ) {
           _, _, file, lines = string.find(exp, "^(%S+)%s(.+)");
        }
        client->send("LOAD " .. tostring(#lines) .. " " .. file .. "\n");
        client->send(lines);
      } else {
        var file = io.open(exp, "r");
        if( ! file && pcall(require, "winapi") ) {
          // if file is not open and winapi is there, try with a short path;
          // this may be needed for unicode paths on windows
          winapi.set_encoding(winapi.CP_UTF8);
          var shortp = winapi.short_path(exp);
          file = shortp && io.open(shortp, "r");
        }
        if( ! file ) { return null, null, "Cannot open file " .. exp; }
        // read the file and remove the shebang line as it causes a compilation error
        var lines = file->read("*all")->gsub("^#!.-\n", "\n");
        file->close();

        file = string.gsub(exp, "\\", "/"); // convert slash
        file = removebasedir(file, basedir);
        client->send("LOAD " .. tostring(#lines) .. " " .. file .. "\n");
        if( #lines > 0 ) { client->send(lines); }
      }
      while( true ) {
        var params, err = client->receive();
        if( ! params ) {
          return null, null, "Debugger connection " .. (err || "error");
        }
        var done = true;
        var _, _, status, len = string.find(params, "^(%d+).-%s+(%d+)%s*$");
        if( status == "200" ) {
          len = tonumber(len);
          if( len > 0 ) {
            var status, res;
            var str = client->receive(len);
            // handle serialized table with results
            var func, err = loadstring(str);
            if( func ) {
              status, res = pcall(func);
              if( ! status ) { err = res;
              } else if( type(res) != "table" ) {
                err = "received "..type(res).." instead of expected 'table'";
              }
            }
            if( err ) {
              print("Error in processing results: " .. err);
              return null, null, "Error in processing results: " .. err;
            }
            print(unpack(res));
            return res[1], res;
          }
        } else if( status == "201" ) {
          _, _, file, line = string.find(params, "^201 Started%s+(.-)%s+(%d+)%s*$");
        } else if( status == "202" || params == "200 OK" ) {
          // do nothing; this only happens when RE/LOAD command gets the response
          // that was for the original command that was aborted
        } else if( status == "204" ) {
          var _, _, stream, size = string.find(params, "^204 Output (%w+) (%d+)$");
          if( stream && size ) {
            var size = tonumber(size);
            var msg = size > 0 && client->receive(size) || "";
            print(msg);
            if( outputs[stream] ) { outputs[stream](msg); }
            // this was just the output, so go back reading the response
            done = false;
          }
        } else if( status == "401" ) {
          len = tonumber(len);
          var res = client->receive(len);
          print("Error in expression: " .. res);
          return null, null, res;
        } else {
          print("Unknown error");
          return null, null, "Debugger error: unexpected response after EXEC/LOAD '" .. params .. "'";
        }
        if( done ) { break; }
      }
    } else {
      print("Invalid command");
    }
  } else if( command == "listb" ) {
    for( l, v in pairs(breakpoints) ) {
      for( f in pairs(v) ) {
        print(f .. ": " .. l);
      }
    }
  } else if( command == "listw" ) {
    for( i, v in pairs(watches) ) {
      print("Watch exp. " .. i .. ": " .. v);
    }
  } else if( command == "suspend" ) {
    client->send("SUSPEND\n");
  } else if( command == "stack" ) {
    var opts = string.match(params, "^[a-z]+%s+(.+)$");
    client->send("STACK" .. (opts && " "..opts || "") .."\n");
    var resp = client->receive();
    var _, _, status, res = string.find(resp, "^(%d+)%s+%w+%s+(.+)%s*$");
    if( status == "200" ) {
      var func, err = loadstring(res);
      if( func == null ) {
        print("Error in stack information: " .. err);
        return null, null, err;
      }
      var ok, stack = pcall(func);
      if( ! ok ) {
        print("Error in stack information: " .. stack);
        return null, null, stack;
      }
      for( _,frame in ipairs(stack) ) {
        print(mobdebug.line(frame[1], {comment = false}));
      }
      return stack;
    } else if( status == "401" ) {
      var _, _, len = string.find(resp, "%s+(%d+)%s*$");
      len = tonumber(len);
      var res = len > 0 && client->receive(len) || "Invalid stack information.";
      print("Error in expression: " .. res);
      return null, null, res;
    } else {
      print("Unknown error");
      return null, null, "Debugger error: unexpected response after STACK";
    }
  } else if( command == "output" ) {
    var _, _, stream, mode = string.find(params, "^[a-z]+%s+(%w+)%s+([dcr])%s*$");
    if( stream && mode ) {
      client->send("OUTPUT "..stream.." "..mode.."\n");
      var resp, err = client->receive();
      if( ! resp ) {
        print("Unknown error: "..err);
        return null, null, "Debugger connection error: "..err;
      }
      var _, _, status = string.find(resp, "^(%d+)%s+%w+%s*$");
      if( status == "200" ) {
        print("Stream "..stream.." redirected");
        outputs[stream] = type(options) == 'table' && options.handler || null;
      // the client knows when she is doing, so install the handler
      } else if( type(options) == 'table' && options.handler ) {
        outputs[stream] = options.handler;
      } else {
        print("Unknown error");
        return null, null, "Debugger error: can't redirect "..stream;
      }
    } else {
      print("Invalid command");
    }
  } else if( command == "basedir" ) {
    var _, _, dir = string.find(params, "^[a-z]+%s+(.+)$");
    if( dir ) {
      dir = string.gsub(dir, "\\", "/"); // convert slash
      if( ! string.find(dir, "/$") ) { dir = dir .. "/"; }

      var remdir = dir->match("\t(.+)");
      if( remdir ) { dir = dir->gsub("/?\t.+", "/"); }
      basedir = dir;

      client->send("BASEDIR "..(remdir || dir).."\n");
      var resp, err = client->receive();
      if( ! resp ) {
        print("Unknown error: "..err);
        return null, null, "Debugger connection error: "..err;
      }
      var _, _, status = string.find(resp, "^(%d+)%s+%w+%s*$");
      if( status == "200" ) {
        print("New base directory is " .. basedir);
      } else {
        print("Unknown error");
        return null, null, "Debugger error: unexpected response after BASEDIR";
      }
    } else {
      print(basedir);
    }
  } else if( command == "help" ) {
    print("setb <file> <line>    // sets a breakpoint");
    print("delb <file> <line>    // removes a breakpoint");
    print("delallb               // removes all breakpoints");
    print("setw <exp>            // adds a new watch expression");
    print("delw <index>          // removes the watch expression at index");
    print("delallw               // removes all watch expressions");
    print("run                   // runs until next breakpoint");
    print("step                  // runs until next line, stepping into function calls");
    print("over                  // runs until next line, stepping over function calls");
    print("out                   // runs until line after returning from current function");
    print("listb                 // lists breakpoints");
    print("listw                 // lists watch expressions");
    print("eval <exp>            // evaluates expression on the current context and returns its value");
    print("exec <stmt>           // executes statement on the current context");
    print("load <file>           // loads a local file for debugging");
    print("reload                // restarts the current debugging session");
    print("stack                 // reports stack trace");
    print("output stdout <d|c|r> // capture and redirect io stream (default|copy|redirect)");
    print("basedir [<path>]      // sets the base path of the remote application, or shows the current one");
    print("done                  // stops the debugger and continues application execution");
    print("exit                  // exits debugger and the application");
  } else {
    var _, _, spaces = string.find(params, "^(%s*)$");
    if( spaces ) {
      return null, null, "Empty command";
    } else {
      print("Invalid command");
      return null, null, "Invalid command";
    }
  }
  return file, line;
}

// Starts debugging server
var function listen(host, port) {
  host = host || "*";
  port = port || mobdebug.port;

  var socket = require ("socket");

  print("Lua Remote Debugger");
  print("Run the program you wish to debug");

  var server = socket.bind(host, port);
  var client = server->accept();

  client->send("STEP\n");
  client->receive();

  var breakpoint = client->receive();
  var _, _, file, line = string.find(breakpoint, "^202 Paused%s+(.-)%s+(%d+)%s*$");
  if( file && line ) {
    print("Paused at file " .. file );
    print("Type 'help' for commands");
  } else {
    var _, _, size = string.find(breakpoint, "^401 Error in Execution (%d+)%s*$");
    if( size ) {
      print("Error in remote application: ");
      print(client->receive(size));
    }
  }

  while( true ) {
    io.write("> ");
    var file, line, err = handle(io.read("*line"), client);
    if( ! file && err == false ) { break; } // completed debugging
  }

  client->close();
}

var cocreate;
var function coro() {
  if( cocreate ) { return; } // only set once
  cocreate = cocreate || coroutine.create;
  coroutine.create = function(f, ...) {
    return cocreate(function(...) {
      mobdebug.on();
      return f(...);
    }, ...);
  };
}

var moconew;
var function moai() {
  if( moconew ) { return; } // only set once
  moconew = moconew || (MOAICoroutine && MOAICoroutine.new);
  if( ! moconew ) { return; }
  MOAICoroutine.new = function(...) {
    var thread = moconew(...);
    // need to support both thread.run and getmetatable(thread).run, which
    // was used in earlier MOAI versions
    var mt = thread.run && thread || getmetatable(thread);
    var patched = mt.run;
    mt.run = function(this, f, ...) {
      return patched(this,  function(...) {
        mobdebug.on();
        return f(...);
      }, ...);
    };
    return thread;
  };
}

// make public functions available
mobdebug.setbreakpoint = set_breakpoint;
mobdebug.removebreakpoint = remove_breakpoint;
mobdebug.listen = listen;
mobdebug.loop = loop;
mobdebug.scratchpad = scratchpad;
mobdebug.handle = handle;
mobdebug.connect = connect;
mobdebug.start = start;
mobdebug.on = on;
mobdebug.off = off;
mobdebug.moai = moai;
mobdebug.coro = coro;
mobdebug.done = done;
mobdebug.pause = function() { step_into = true; };
mobdebug.yield = null; // callback
mobdebug.output = output;
mobdebug.onexit = os && os.exit || done;
mobdebug.onscratch = null; // callback
mobdebug.basedir = function(b) { if( b ) { basedir = b; } return basedir; };

return mobdebug;
